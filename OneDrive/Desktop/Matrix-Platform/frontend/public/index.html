<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified Messaging Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --light-bg: #f8f9fa;
            --dark-bg: #343a40;
            --sidebar-width: 350px;
            --header-height: 60px;
            --input-height: 50px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .screen {
            display: none;
            height: 100vh;
        }

        .screen.active {
            display: flex;
        }

        /* Login Styles */
        .login-container {
            background: white;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 400px;
            margin: auto;
        }

        .login-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .login-header h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .login-header p {
            color: #666;
            font-size: 1rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .btn-primary {
            width: 100%;
            padding: 15px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
            margin-bottom: 10px;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-google {
            width: 100%;
            padding: 15px;
            background: #db4437;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s ease;
            margin-bottom: 10px;
        }

        .btn-google:hover {
            background: #c23321;
        }

        .btn-secondary {
            width: 100%;
            padding: 12px;
            background: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: var(--primary-color);
            color: white;
        }

        .divider {
            text-align: center;
            margin: 20px 0;
            color: #666;
            position: relative;
        }

        .divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e1e5e9;
        }

        .divider span {
            background: white;
            padding: 0 15px;
        }

        /* Main App Layout */
        #appScreen {
            display: flex;
            background: white;
        }

        .sidebar {
            width: var(--sidebar-width);
            background: var(--light-bg);
            border-right: 1px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e1e5e9;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .user-details {
            flex: 1;
        }

        .user-email {
            font-weight: 600;
            color: #333;
            display: block;
        }

        .logout-btn {
            background: none;
            border: none;
            color: var(--danger-color);
            cursor: pointer;
            font-size: 12px;
            margin-top: 2px;
        }

        .platforms-section {
            padding: 20px;
            border-bottom: 1px solid #e1e5e9;
        }

        .platforms-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .platforms-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .platform-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .platform-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .platform-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            color: white;
            font-size: 18px;
        }

        .platform-icon.whatsapp { background: #25D366; }
        .platform-icon.telegram { background: #0088cc; }
        .platform-icon.instagram { background: #E4405F; }
        .platform-icon.twitter { background: #1DA1F2; }
        .platform-icon.email { background: #6c757d; }

        .platform-card span {
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }

        .platform-status {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .platform-status.connected { background: var(--success-color); }
        .platform-status.disconnected { background: var(--danger-color); }

        .platform-actions {
            margin-top: 8px;
            display: flex;
            gap: 5px;
        }

        .platform-action-btn {
            background: none;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .connect-btn {
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        .connect-btn:hover {
            background: var(--success-color);
            color: white;
        }

        .disconnect-btn {
            color: var(--danger-color);
            border: 1px solid var(--danger-color);
        }

        .disconnect-btn:hover {
            background: var(--danger-color);
            color: white;
        }

        .rooms-section {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .rooms-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .rooms-header h3 {
            color: #333;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-icon {
            background: none;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            color: #666;
            transition: all 0.3s ease;
        }

        .btn-icon:hover {
            background: #e9ecef;
            color: #333;
        }

        .rooms-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .room-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease;
            gap: 12px;
            position: relative;
        }

        .room-item:hover {
            background: #e9ecef;
        }

        .room-item.active {
            background: var(--primary-color);
            color: white;
        }

        .room-item.unread {
            background: rgba(0, 123, 255, 0.05);
            border-left: 3px solid var(--primary-color);
        }

        .room-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #6c757d;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .room-details {
            flex: 1;
            min-width: 0;
        }

        .room-name {
            font-weight: 600;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .room-last-message {
            font-size: 12px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .room-item.active .room-last-message {
            color: rgba(255,255,255,0.8);
        }

        .room-item.unread .room-last-message {
            color: #333;
            font-weight: 500;
        }

        .room-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .room-time {
            font-size: 11px;
            color: #999;
        }

        .room-item.active .room-time {
            color: rgba(255,255,255,0.8);
        }

        .room-item.unread .room-time {
            color: var(--primary-color);
            font-weight: 600;
        }

        .room-unread {
            background: var(--primary-color);
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: 600;
            min-width: 18px;
            text-align: center;
        }

        .room-item.active .room-unread {
            background: white;
            color: var(--primary-color);
        }

        /* Chat Area */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        .no-chat-selected {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--light-bg);
        }

        .no-chat-content {
            text-align: center;
            color: #666;
        }

        .no-chat-content i {
            font-size: 4rem;
            margin-bottom: 20px;
            color: #ccc;
        }

        .no-chat-content h2 {
            margin-bottom: 10px;
            color: #333;
        }

        .active-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .hidden {
            display: none !important;
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #e1e5e9;
            background: white;
            flex-shrink: 0;
        }

        .chat-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .chat-details h3 {
            margin-bottom: 2px;
            color: #333;
        }

        .chat-status {
            font-size: 12px;
            color: var(--success-color);
        }

        .chat-actions {
            display: flex;
            gap: 10px;
        }

        /* Enhanced Messages Container for Scrolling */
        .messages-container {
            flex: 1;
            background: var(--light-bg);
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .messages-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: min-content;
        }

        .message {
            display: flex;
            max-width: 70%;
            animation: messageAppear 0.3s ease;
            position: relative;
        }

        @keyframes messageAppear {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.sent {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message.received {
            align-self: flex-start;
        }

        .message-bubble {
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
            max-width: 100%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .message.sent .message-bubble {
            background: var(--primary-color);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.received .message-bubble {
            background: white;
            color: #333;
            border: 1px solid #e1e5e9;
            border-bottom-left-radius: 4px;
        }

        .message-sender {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 4px;
            color: var(--primary-color);
        }

        .message.sent .message-sender {
            display: none;
        }

        .message-content {
            margin-bottom: 4px;
        }

        .message-media {
            max-width: 300px;
            max-height: 300px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .message-media:hover {
            transform: scale(1.02);
        }

        .message-time {
            font-size: 11px;
            opacity: 0.7;
            text-align: right;
            margin-top: 4px;
        }

        /* Enhanced Message Input Area */
        .message-input-container {
            padding: 15px 20px;
            background: white;
            border-top: 1px solid #e1e5e9;
            position: relative;
            flex-shrink: 0;
        }

        .message-input-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 10px;
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 25px;
            padding: 8px 15px;
            transition: border-color 0.3s ease;
        }

        .message-input-wrapper:focus-within {
            border-color: var(--primary-color);
        }

        .message-input {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .message-input textarea {
            width: 100%;
            border: none;
            background: none;
            resize: none;
            outline: none;
            font-size: 14px;
            line-height: 1.4;
            max-height: 120px;
            font-family: inherit;
            padding: 8px 0;
        }

        /* Input Actions */
        .input-actions {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .action-btn {
            background: none;
            border: none;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            color: #666;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .action-btn:disabled:hover {
            background: none;
            color: #666;
        }

        .send-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .send-btn:hover:not(:disabled) {
            background: #0056b3;
            transform: scale(1.05);
        }

        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* File Input Styling */
        .file-input-wrapper {
            position: relative;
        }

        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* Auto-scroll indicator */
        .auto-scroll-indicator {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            z-index: 10;
        }

        .auto-scroll-indicator:hover {
            transform: scale(1.1);
            background: #0056b3;
        }

        /* Character counter */
        .char-counter {
            text-align: right;
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }

        /* Scrollbar Styling */
        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .messages-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Reaction System Styles */
        .message-reactions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .reaction {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e1e5e9;
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 2px;
            max-width: 60px;
        }

        .reaction:hover {
            background: #f8f9fa;
            transform: scale(1.05);
        }

        .reaction.own-reaction {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .message.sent .reaction {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            color: white;
        }

        .message.sent .reaction:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .message.sent .reaction.own-reaction {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(255, 255, 255, 0.9);
            color: var(--primary-color);
        }

        .reaction-count {
            font-size: 10px;
            font-weight: 600;
        }

        /* Reaction Button on Messages */
        .message-reaction-trigger {
            position: absolute;
            top: -10px;
            right: 5px;
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex !important;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            font-size: 12px;
            z-index: 5;
            opacity: 1 !important;
            visibility: visible !important;
        }

        .message:hover .message-reaction-trigger {
            display: flex !important;
            opacity: 1 !important;
        }

        .message-reaction-trigger:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: scale(1.1);
        }

        /* Emoji Picker Styles */
        .emoji-picker {
            position: fixed;
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            padding: 15px;
            z-index: 10000;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .emoji-picker.show {
            display: block;
        }

        .emoji-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e1e5e9;
        }

        .emoji-picker-header h4 {
            margin: 0;
            color: #333;
            font-size: 14px;
        }

        .emoji-picker-search {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .emoji-picker-search:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .emoji-categories {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            border-bottom: 1px solid #e1e5e9;
            padding-bottom: 8px;
        }

        .emoji-category {
            background: none;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }

        .emoji-category:hover,
        .emoji-category.active {
            background: var(--primary-color);
            color: white;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .emoji-item {
            background: none;
            border: none;
            padding: 6px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .emoji-item:hover {
            background: #f8f9fa;
            transform: scale(1.2);
        }

        .emoji-section {
            margin-bottom: 15px;
        }

        .emoji-section h5 {
            margin: 0 0 8px 0;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Quick Reactions */
        .quick-reactions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e1e5e9;
        }

        .quick-reaction {
            background: none;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            padding: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quick-reaction:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }

        /* Reaction Tooltip */
        .reaction-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            display: none;
        }

        .reaction:hover .reaction-tooltip {
            display: block;
        }

        /* Message container for positioning */
        .message {
            position: relative;
        }

        /* AI Suggestions */
        .ai-suggestions {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .ai-suggestions.show {
            display: block;
        }

        .ai-suggestion-item {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .ai-suggestion-item:hover {
            background: #f8f9fa;
        }

        .ai-suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-text {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .suggestion-meta {
            font-size: 11px;
            color: #666;
        }

        /* Loading Spinner */
        .loading-spinner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        /* AI Rephrase Modal Styles */
.tone-select {
    background: white;
    border: 2px solid #e1e5e9;
    border-radius: 8px;
    padding: 12px 15px;
    font-size: 14px;
    transition: border-color 0.3s ease;
    cursor: pointer;
}

.tone-select:focus {
    outline: none;
    border-color: var(--primary-color);
}

.tone-option {
    padding: 10px 15px;
    margin: 5px 0;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.tone-option:hover {
    background: #f8f9fa;
}

.tone-option.selected {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

.ai-loading {
    position: relative;
    opacity: 0.7;
}

.ai-loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

/* Enhanced AI Button */
.ai-rephrase-btn.loading {
    position: relative;
    color: transparent;
}

.ai-rephrase-btn.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 3000;
        }

        .toast {
            background: white;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid var(--primary-color);
            animation: toastSlideIn 0.3s ease;
        }

        .toast.success { border-left-color: var(--success-color); }
        .toast.error { border-left-color: var(--danger-color); }
        .toast.warning { border-left-color: var(--warning-color); }
        .toast.info { border-left-color: var(--info-color); }
/* FIXED: AI Rephrase Modal Styles */
#aiRephraseModal {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgba(0,0,0,0.5) !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    z-index: 10000 !important;
    opacity: 1 !important;
    visibility: visible !important;
}

#aiRephraseModal.hidden {
    display: none !important;
}

#aiRephraseModal .modal-content {
    background: white !important;
    border-radius: 12px !important;
    width: 90% !important;
    max-width: 500px !important;
    max-height: 90vh !important;
    overflow-y: auto !important;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3) !important;
    position: relative !important;
    margin: 20px !important;
}

#aiRephraseModal .modal-header {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    padding: 20px !important;
    border-bottom: 1px solid #e1e5e9 !important;
    background: white !important;
    position: sticky !important;
    top: 0 !important;
    z-index: 1 !important;
}

#aiRephraseModal .modal-header h3 {
    margin: 0 !important;
    color: #333 !important;
    font-size: 1.5rem !important;
}

#aiRephraseModal .close-modal {
    background: none !important;
    border: none !important;
    font-size: 24px !important;
    cursor: pointer !important;
    color: #666 !important;
    padding: 0 !important;
    width: 30px !important;
    height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    transition: color 0.3s ease !important;
}

#aiRephraseModal .close-modal:hover {
    color: #333 !important;
}

#aiRephraseModal .modal-body {
    padding: 20px !important;
}

#aiRephraseModal .form-group {
    margin-bottom: 20px !important;
}

#aiRephraseModal label {
    display: block !important;
    margin-bottom: 8px !important;
    font-weight: 600 !important;
    color: #333 !important;
}

#aiRephraseModal textarea, 
#aiRephraseModal select, 
#aiRephraseModal input {
    width: 100% !important;
    padding: 12px !important;
    border: 1px solid #e1e5e9 !important;
    border-radius: 6px !important;
    font-size: 14px !important;
    font-family: inherit !important;
    box-sizing: border-box !important;
}

#aiRephraseModal textarea:focus, 
#aiRephraseModal select:focus, 
#aiRephraseModal input:focus {
    outline: none !important;
    border-color: var(--primary-color) !important;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1) !important;
}

#aiRephraseModal textarea {
    resize: vertical !important;
    min-height: 80px !important;
}

#aiRephraseModal .modal-actions {
    display: flex !important;
    gap: 10px !important;
    margin-top: 20px !important;
}

#aiRephraseModal .btn-primary,
#aiRephraseModal .btn-secondary {
    flex: 1 !important;
    padding: 12px !important;
    border: none !important;
    border-radius: 6px !important;
    font-size: 14px !important;
    font-weight: 600 !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    gap: 8px !important;
}

#aiRephraseModal .btn-primary {
    background: var(--primary-color) !important;
    color: white !important;
}

#aiRephraseModal .btn-primary:hover:not(:disabled) {
    background: #0056b3 !important;
}

#aiRephraseModal .btn-primary:disabled {
    background: #ccc !important;
    cursor: not-allowed !important;
    opacity: 0.6 !important;
}

#aiRephraseModal .btn-secondary {
    background: transparent !important;
    color: var(--primary-color) !important;
    border: 2px solid var(--primary-color) !important;
}

#aiRephraseModal .btn-secondary:hover {
    background: var(--primary-color) !important;
    color: white !important;
}

/* Tone selection styles */
#aiRephraseModal .tone-option {
    padding: 10px 15px;
    margin: 5px 0;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
    background: #f8f9fa;
}

#aiRephraseModal .tone-option:hover {
    background: #e9ecef;
}

#aiRephraseModal .tone-option.selected {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}
        @keyframes toastSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Modals */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e1e5e9;
        }

        .modal-header h3 {
            margin: 0;
            color: #333;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-body input {
            width: 100%;
            padding: 12px;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .qr-info, .login-status {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
        }

        .qr-code {
            text-align: center;
            margin: 20px 0;
        }

        .qr-code img {
            max-width: 100%;
            height: auto;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
        }

        /* NEW: Reply Preview Styles */
        .reply-preview {
            background: #f8f9fa;
            border-left: 3px solid var(--primary-color);
            border-radius: 8px;
            padding: 10px 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .reply-preview:hover {
            background: #e9ecef;
        }

        .reply-preview-content {
            flex: 1;
            overflow: hidden;
        }

        .reply-preview-header {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 4px;
        }

        .reply-preview-text {
            font-size: 13px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cancel-reply {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            margin-left: 10px;
            transition: color 0.2s ease;
        }

        .cancel-reply:hover {
            color: var(--danger-color);
        }

        /* NEW: Message Reply Styles */
        .message-reply {
            background: rgba(0, 123, 255, 0.1);
            border-left: 2px solid var(--primary-color);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
            max-width: 100%;
            overflow: hidden;
        }

        .message-reply:hover {
            background: rgba(0, 123, 255, 0.15);
        }

        .message-reply-header {
            font-size: 11px;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 2px;
        }

        .message-reply-text {
            font-size: 12px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message.sent .message-reply {
            background: rgba(255, 255, 255, 0.2);
            border-left-color: rgba(255, 255, 255, 0.7);
        }

        .message.sent .message-reply-header {
            color: rgba(255, 255, 255, 0.9);
        }

        .message.sent .message-reply-text {
            color: rgba(255, 255, 255, 0.8);
        }

        /* NEW: Message Context Menu */
        .message-context-menu {
            position: absolute;
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            min-width: 150px;
            display: none;
        }

        .message-context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .context-menu-item:hover {
            background: #f8f9fa;
        }

        .context-menu-item i {
            width: 16px;
            text-align: center;
        }

        /* Media Preview Styles */
        .media-preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .media-preview-item {
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: 6px;
            overflow: hidden;
        }

        .media-preview-item img,
        .media-preview-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .media-preview-item .file-preview {
            width: 100%;
            height: 100%;
            background: var(--primary-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            padding: 5px;
        }

        .remove-media {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Download Button for Media */
        .download-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e1e5e9;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-top: 4px;
            transition: all 0.2s ease;
        }

        .download-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* NEW: Sync Status Styles */
        .sync-status {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: var(--warning-color);
            color: #000;
            padding: 10px 20px;
            text-align: center;
            z-index: 10000;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .sync-status.hidden {
            display: none;
        }

        /* NEW: Others Platform Section */
        .others-section {
            margin-top: 10px;
            padding: 15px;
            background: rgba(108, 117, 125, 0.1);
            border-radius: 8px;
        }

        .others-section h4 {
            margin-bottom: 10px;
            color: #666;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .others-rooms {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .others-room-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid var(--secondary-color);
        }

        .others-room-item:hover {
            background: #f0f0f0;
        }

        .others-room-item.active {
            background: var(--secondary-color);
            color: white;
        }

        .others-room-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            margin-right: 10px;
            font-size: 12px;
        }

        .others-room-details {
            flex: 1;
            min-width: 0;
        }

        .others-room-name {
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .others-room-platform {
            font-size: 10px;
            color: #999;
        }

        .others-room-item.active .others-room-platform {
            color: rgba(255,255,255,0.8);
        }

        .others-room-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .others-room-time {
            font-size: 10px;
            color: #999;
        }

        .others-room-unread {
            background: var(--primary-color);
            color: white;
            border-radius: 8px;
            padding: 1px 5px;
            font-size: 9px;
            font-weight: 600;
            min-width: 16px;
            text-align: center;
        }

        .others-room-item.active .others-room-unread {
            background: white;
            color: var(--primary-color);
        }
        /* Enhanced QR Code Styles */
/* Enhanced QR Code Styles */
.qr-code {
    background: white;
    padding: 20px;
    border-radius: 12px;
    border: 1px solid #e1e5e9;
    margin: 15px 0;
    text-align: center;
}

.qr-status {
    padding: 12px 15px;
    border-radius: 6px;
    margin: 10px 0;
    font-size: 14px;
    text-align: center;
}

.qr-status.info {
    background: #e7f3ff;
    border: 1px solid #b8daff;
    color: #004085;
}

.qr-status.success {
    background: #e7f6e9;
    border: 1px solid #c3e6cb;
    color: #0f5132;
}

.qr-status.error {
    background: #fde8e8;
    border: 1px solid #f5c6cb;
    color: #721c24;
}

.qr-status.warning {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    color: #856404;
}

.qr-instructions {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid var(--primary-color);
    text-align: left;
    margin-top: 15px;
}

.qr-instructions ol {
    margin: 10px 0;
    padding-left: 20px;
}

.qr-instructions li {
    margin-bottom: 8px;
    line-height: 1.4;
}

/* Loading animation */
.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
            }
            
            .platforms-grid {
                grid-template-columns: 1fr;
            }
            
            .message {
                max-width: 85%;
            }
            
            .chat-area:not(.hidden) ~ .sidebar {
                display: none;
            }
            
            .emoji-picker {
                width: 280px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- NEW: Sync Status Banner -->
    <div id="syncStatus" class="sync-status hidden">
        <i class="fas fa-sync-alt fa-spin"></i> Please wait, your chats are syncing...
    </div>

    <!-- Login Screen -->
    <div id="loginScreen" class="screen active">
        <div class="login-container">
            <div class="login-header">
                <h1>ðŸš€ Unified Messaging</h1>
                <p>Connect all your messaging platforms in one place</p>
            </div>
            
            <div class="login-form">
                <div class="form-group">
                    <input type="email" id="loginEmail" placeholder="Email address" required>
                </div>
                <div class="form-group">
                    <input type="password" id="loginPassword" placeholder="Password" required>
                </div>
                <button id="loginBtn" class="btn-primary">Sign In</button>
                <button id="googleLoginBtn" class="btn-google">
                    <i class="fab fa-google"></i> Sign in with Google
                </button>
                <div class="divider">or</div>
                <button id="showRegisterBtn" class="btn-secondary">Create Account</button>
            </div>
        </div>
    </div>

    <!-- Register Screen -->
    <div id="registerScreen" class="screen">
        <div class="login-container">
            <div class="login-header">
                <h1>Create Account</h1>
                <p>Join the unified messaging platform</p>
            </div>
            
            <div class="login-form">
                <div class="form-group">
                    <input type="email" id="registerEmail" placeholder="Email address" required>
                </div>
                <div class="form-group">
                    <input type="password" id="registerPassword" placeholder="Password" required>
                </div>
                <button id="registerBtn" class="btn-primary">Create Account</button>
                <button id="showLoginBtn" class="btn-secondary">Back to Sign In</button>
            </div>
        </div>
    </div>

    <!-- Main App Screen -->
    <div id="appScreen" class="screen">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="user-info">
                    <div class="user-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="user-details">
                        <span id="userEmail" class="user-email"></span>
                        <button id="logoutBtn" class="logout-btn">Logout</button>
                    </div>
                </div>
            </div>

            <!-- Platform Connections -->
            <div class="platforms-section">
                <h3>Connect Platforms</h3>
                <div class="platforms-grid">
                    <div class="platform-card" data-platform="whatsapp">
                        <div class="platform-icon whatsapp">
                            <i class="fab fa-whatsapp"></i>
                        </div>
                        <span>WhatsApp</span>
                        <div class="platform-status disconnected"></div>
                        <div class="platform-actions">
                            <button class="platform-action-btn connect-btn" data-platform="whatsapp">Login</button>
                            <button class="platform-action-btn disconnect-btn" data-platform="whatsapp" style="display: none;">Logout</button>
                        </div>
                    </div>
                    <div class="platform-card" data-platform="telegram">
                        <div class="platform-icon telegram">
                            <i class="fab fa-telegram"></i>
                        </div>
                        <span>Telegram</span>
                        <div class="platform-status disconnected"></div>
                        <div class="platform-actions">
                            <button class="platform-action-btn connect-btn" data-platform="telegram">Login</button>
                            <button class="platform-action-btn disconnect-btn" data-platform="telegram" style="display: none;">Logout</button>
                        </div>
                    </div>
                    <div class="platform-card" data-platform="instagram">
                        <div class="platform-icon instagram">
                            <i class="fab fa-instagram"></i>
                        </div>
                        <span>Instagram</span>
                        <div class="platform-status disconnected"></div>
                        <div class="platform-actions">
                            <button class="platform-action-btn connect-btn" data-platform="instagram">Login</button>
                            <button class="platform-action-btn disconnect-btn" data-platform="instagram" style="display: none;">Logout</button>
                        </div>
                    </div>
                    <div class="platform-card" data-platform="twitter">
                        <div class="platform-icon twitter">
                            <i class="fab fa-twitter"></i>
                        </div>
                        <span>Twitter</span>
                        <div class="platform-status disconnected"></div>
                        <div class="platform-actions">
                            <button class="platform-action-btn connect-btn" data-platform="twitter">Login</button>
                            <button class="platform-action-btn disconnect-btn" data-platform="twitter" style="display: none;">Logout</button>
                        </div>
                    </div>
                    <div class="platform-card" data-platform="email">
                        <div class="platform-icon email">
                            <i class="fas fa-envelope"></i>
                        </div>
                        <span>Email</span>
                        <div class="platform-status disconnected"></div>
                        <div class="platform-actions">
                            <button class="platform-action-btn connect-btn" data-platform="email">Login</button>
                            <button class="platform-action-btn disconnect-btn" data-platform="email" style="display: none;">Logout</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Rooms List -->
            <div class="rooms-section">
                <div class="rooms-header">
                    <h3>Conversations</h3>
                    <button id="createGroupBtn" class="btn-icon" title="Create Group">
                        <i class="fas fa-users"></i>
                    </button>
                    <button id="manualSyncBtn" class="btn-icon" title="Manual Sync">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                </div>
                <div id="roomsList" class="rooms-list">
                    <!-- Rooms will be populated here -->
                </div>
                
                <!-- NEW: Others Rooms Section -->
                <div id="othersSection" class="others-section hidden">
                    <h4>Other Platforms</h4>
                    <div id="othersRoomsList" class="others-rooms">
                        <!-- Other platform rooms will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat-area">
            <!-- No Chat Selected -->
            <div id="noChatSelected" class="no-chat-selected">
                <div class="no-chat-content">
                    <i class="fas fa-comments"></i>
                    <h2>Select a conversation</h2>
                    <p>Choose a conversation from the sidebar to start messaging</p>
                </div>
            </div>

            <!-- Active Chat -->
            <div id="activeChat" class="active-chat hidden">
                <!-- Chat Header -->
                <div class="chat-header">
                    <div class="chat-info">
                        <div class="chat-avatar">
                            <i class="fas fa-user-friends"></i>
                        </div>
                        <div class="chat-details">
                            <h3 id="chatRoomName">Loading...</h3>
                            <span id="chatRoomStatus" class="chat-status">Online</span>
                        </div>
                    </div>
                    <div class="chat-actions">
                        <button class="btn-icon" title="Search">
                            <i class="fas fa-search"></i>
                        </button>
                        <button class="btn-icon" title="More options">
                            <i class="fas fa-ellipsis-v"></i>
                        </button>
                    </div>
                </div>

                <!-- Messages Area -->
                <div id="messagesContainer" class="messages-container">
                    <div id="messagesList" class="messages-list">
                        <!-- Messages will be populated here -->
                    </div>
                </div>

                <!-- NEW: Media Preview Area -->
                <div id="mediaPreview" class="media-preview-container hidden">
                    <!-- Media previews will be populated here -->
                </div>

                <!-- NEW: Reply Preview Area -->
                <div id="replyPreview" class="reply-preview hidden">
                    <div class="reply-preview-content">
                        <div class="reply-preview-header">Replying to <span id="replyPreviewSender"></span></div>
                        <div class="reply-preview-text" id="replyPreviewText"></div>
                    </div>
                    <button class="cancel-reply" id="cancelReplyBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Enhanced Message Input -->
                <div class="message-input-container">
                    <!-- Auto-scroll indicator -->
                    <div id="autoScrollIndicator" class="auto-scroll-indicator hidden" title="Scroll to bottom">
                        <i class="fas fa-arrow-down"></i>
                    </div>
                    
                    <div class="message-input-wrapper">
                        <!-- File Attachment -->
                        <div class="file-input-wrapper">
                            <input type="file" id="fileInput" hidden accept="*/*" multiple>
                            <label for="fileInput" class="file-input-label action-btn" title="Attach files">
                                <i class="fas fa-paperclip"></i>
                            </label>
                        </div>
                        
                        <!-- AI Rephrase Button -->
                        <button class="action-btn ai-rephrase-btn" id="aiRephraseBtn" title="Rephrase with AI">
                            <i class="fas fa-star sparkle-icon"></i>
                        </button>
                        
                        <!-- Message Input -->
                        <div class="message-input">
                            <textarea 
                                id="messageInput" 
                                placeholder="Type a message..." 
                                rows="1"
                                maxlength="5000"
                            ></textarea>
                        </div>
                        
                        <!-- Input Actions -->
                        <div class="input-actions">
                            <!-- Emoji Picker -->
                            <button class="action-btn" id="emojiBtn" title="Add emoji">
                                <i class="fas fa-smile"></i>
                            </button>
                            
                            <!-- Send Button -->
                            <button id="sendMessageBtn" class="send-btn" disabled title="Send message">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Character counter -->
                    <div id="charCounter" class="char-counter">
                        0/5000
                    </div>
                </div>
            </div>
        </div>

        <!-- NEW: Message Context Menu -->
        <div id="messageContextMenu" class="message-context-menu">
            <div class="context-menu-item" id="replyContextItem">
                <i class="fas fa-reply"></i>
                <span>Reply</span>
            </div>
            <div class="context-menu-item" id="copyContextItem">
                <i class="fas fa-copy"></i>
                <span>Copy</span>
            </div>
            <div class="context-menu-item" id="deleteContextItem">
                <i class="fas fa-trash"></i>
                <span>Delete</span>
            </div>
        </div>

        <!-- Bridge Login Modals -->
        <!-- Improved WhatsApp Modal -->
<!-- Improved WhatsApp Modal -->
<div id="whatsappModal" class="modal hidden">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Connect WhatsApp</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div class="login-methods">
                <button id="whatsappQRMethod" class="btn-primary" style="margin-bottom: 10px; width: 100%;">
                    <i class="fas fa-qrcode"></i> Login with QR Code
                </button>
                <button id="whatsappPhoneMethod" class="btn-secondary" style="width: 100%;">
                    <i class="fas fa-phone"></i> Login with Phone Number
                </button>
            </div>
            
            <!-- QR Code Section -->
            <div id="whatsappQRInfo" class="qr-info hidden">
                <p><strong>Scan the QR code below with your WhatsApp:</strong></p>
                
                <!-- QR Code Container with better styling -->
                <div id="whatsappQRCode" class="qr-code" style="text-align: center; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 12px;">
                    <div id="qrLoading" style="display: none;">
                        <div class="spinner" style="width: 40px; height: 40px; margin: 0 auto;"></div>
                        <p>Generating QR code...</p>
                    </div>
                    <div id="qrImageContainer">
                        <!-- QR image will be inserted here -->
                    </div>
                    <div id="qrFallback" style="display: none; margin-top: 15px;">
                        <p><strong>Alternative method:</strong></p>
                        <a id="qrDirectLink" href="#" target="_blank" style="word-break: break-all; color: var(--primary-color);"></a>
                    </div>
                </div>
                
                <div class="qr-instructions">
                    <p><strong>Instructions:</strong></p>
                    <ol style="text-align: left; padding-left: 20px;">
                        <li>Open WhatsApp on your phone</li>
                        <li>Tap <strong>Menu â†’ Linked Devices â†’ Link a Device</strong></li>
                        <li>Point your camera at the QR code above</li>
                    </ol>
                </div>
                
                <div id="qrStatus" style="margin-top: 15px; padding: 10px; border-radius: 6px; display: none;"></div>
            </div>
            
            <!-- Phone Login Section -->
            <div id="whatsappPhoneInfo" class="qr-info hidden">
                <p>Enter your phone number with country code:</p>
                <input type="text" id="whatsappPhoneNumber" placeholder="+1234567890" required 
                       style="width: 100%; padding: 12px; margin: 10px 0; border: 1px solid #ddd; border-radius: 6px;">
                <button id="startWhatsAppPhoneLogin" class="btn-primary" style="width: 100%;">
                    Send Verification Code
                </button>
            </div>
            
            <!-- Status Messages -->
            <div id="whatsappStatus" class="login-status hidden" style="margin-top: 15px; padding: 12px; border-radius: 6px;"></div>
        </div>
    </div>
</div>
        <div id="telegramModal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Connect Telegram</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modal-body">
                    <div id="telegramStep1">
                        <p>Enter your phone number with country code:</p>
                        <input type="text" id="telegramPhone" placeholder="+1234567890" required>
                        <button id="startTelegramLogin" class="btn-primary">Send Code</button>
                    </div>
                    <div id="telegramStep2" class="hidden">
                        <p>Enter the verification code sent to your Telegram:</p>
                        <input type="text" id="telegramCode" placeholder="12345" required>
                        <button id="verifyTelegramCode" class="btn-primary">Verify Code</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="instagramModal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Connect Instagram</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modal-body">
                    <p>Click below to start Instagram login. A browser window will open for authentication.</p>
                    <button id="startInstagramLogin" class="btn-primary">Start Instagram Login</button>
                    <div id="instagramStatus" class="login-status hidden">
                        <p>Please complete the login in the browser window.</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="twitterModal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Connect Twitter</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modal-body">
                    <p>Click below to start Twitter login. A browser window will open for authentication.</p>
                    <button id="startTwitterLogin" class="btn-primary">Start Twitter Login</button>
                    <div id="twitterStatus" class="login-status hidden">
                        <p>Please complete the login in the browser window.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create Group Modal -->
        <div id="createGroupModal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Create New Group</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modal-body">
                    <input type="text" id="groupName" placeholder="Group name" required>
                    <input type="text" id="searchUsers" placeholder="Search users to add...">
                    <div id="searchResults" class="search-results"></div>
                    <div id="selectedMembers" class="selected-members"></div>
                    <button id="createGroup" class="btn-primary">Create Group</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div id="emojiPicker" class="emoji-picker">
        <div class="emoji-picker-header">
            <h4>Choose Reaction</h4>
            <button class="close-emoji-picker btn-icon">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <input type="text" class="emoji-picker-search" placeholder="Search emojis...">
        
        <div class="emoji-categories">
            <button class="emoji-category active" data-category="recent">ðŸ•’</button>
            <button class="emoji-category" data-category="smileys">ðŸ˜€</button>
            <button class="emoji-category" data-category="hearts">â¤ï¸</button>
            <button class="emoji-category" data-category="thumbs">ðŸ‘</button>
            <button class="emoji-category" data-category="symbols">ðŸ’¡</button>
        </div>
        
        <div class="emoji-sections">
            <!-- Recent emojis will be populated here -->
            <div class="emoji-section recent-section">
                <h5>Recently Used</h5>
                <div class="emoji-grid" id="recentEmojis">
                    <!-- Recent emojis will be populated here -->
                </div>
            </div>
            
            <div class="emoji-section smileys-section">
                <h5>Smileys & People</h5>
                <div class="emoji-grid" id="smileysEmojis">
                    <!-- Smileys emojis will be populated here -->
                </div>
            </div>
            
            <div class="emoji-section hearts-section">
                <h5>Hearts & Emotions</h5>
                <div class="emoji-grid" id="heartsEmojis">
                    <!-- Hearts emojis will be populated here -->
                </div>
            </div>
            
            <div class="emoji-section thumbs-section">
                <h5>Thumbs & Gestures</h5>
                <div class="emoji-grid" id="thumbsEmojis">
                    <!-- Thumbs emojis will be populated here -->
                </div>
            </div>
        </div>
        <!-- AI Rephrase Modal -->
<!-- Move this AI Rephrase Modal to be a direct child of body -->
<!-- AI Rephrase Modal -->
<div id="aiRephraseModal" class="modal hidden">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Rephrase with AI</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="originalText">Original Message:</label>
                <textarea id="originalText" rows="3" readonly></textarea>
            </div>
            
            <div class="form-group">
                <label for="toneSelect">Select Tone:</label>
                <select id="toneSelect" class="tone-select">
                    <option value="">No specific tone</option>
                    <option value="polite">Polite</option>
                    <option value="friendly">Friendly</option>
                    <option value="request">Request</option>
                    <option value="professional">Professional</option>
                    <option value="order">Order</option>
                    <option value="other">Other</option>
                </select>
            </div>
            
            <div id="customToneContainer" class="form-group hidden">
                <label for="customTone">Custom Tone:</label>
                <input type="text" id="customTone" placeholder="Describe the tone you want...">
            </div>
            
            <div class="modal-actions">
                <button id="cancelRephrase" class="btn-secondary">Cancel</button>
                <button id="confirmRephrase" class="btn-primary">
                    <i class="fas fa-magic"></i> Rephrase
                </button>
            </div>
        </div>
    </div>
</div>        <div class="quick-reactions">
            <button class="quick-reaction" data-emoji="ðŸ‘">ðŸ‘</button>
            <button class="quick-reaction" data-emoji="â¤ï¸">â¤ï¸</button>
            <button class="quick-reaction" data-emoji="ðŸ˜„">ðŸ˜„</button>
            <button class="quick-reaction" data-emoji="ðŸ˜®">ðŸ˜®</button>
            <button class="quick-reaction" data-emoji="ðŸ˜¢">ðŸ˜¢</button>
            <button class="quick-reaction" data-emoji="ðŸ‘">ðŸ‘</button>
        </div>
    </div>

    <!-- Loading Spinner -->
    <div id="loadingSpinner" class="loading-spinner hidden">
        <div class="spinner"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
    // Room Maps
    const whatsappRooms = new Map();
    const telegramRooms = new Map();
    const instagramRooms = new Map();
    const twitterRooms = new Map();
    const emailRooms = new Map();
    // NEW: Others rooms map for unsupported platforms
    const othersRooms = new Map();

    // Message Maps
    const msgWhatsappMap = new Map();  
    const msgTelegramMap = new Map();
    const msgInstagramMap = new Map();
    const msgTwitterMap = new Map();
    const msgEmailMap = new Map();
    // NEW: Others message map
    const msgOthersMap = new Map();

    class UnifiedMessagingApp {
        constructor() {
            this.socket = io();
            this.currentUser = null;
            this.currentRoom = null;
            this.currentPlatform = null;
            this.platformSessions = new Map();
            this.isAutoScrolling = true;
            this.recentEmojis = [];
            this.currentReactionMessage = null;
            
            // NEW: Sync status tracking
            this.isSyncing = false;
            
            // Reply functionality variables
            this.currentReplyMessage = null;
            this.contextMenuMessage = null;
            
            // Media preview variables
            this.selectedFiles = [];
            
            this.initializeEventListeners();
            this.checkExistingSession();
            this.initializeScrolling();
            this.initializeMessageInput();
            this.initializeReactionSystem();
            this.initializeReplySystem();
            this.initSocket();
            this.initializeAIRephrase();
        }

        initializeEventListeners() {
            // Authentication
            document.getElementById('loginBtn').addEventListener('click', () => this.login());
            document.getElementById('registerBtn').addEventListener('click', () => this.register());
            document.getElementById('googleLoginBtn').addEventListener('click', () => this.googleLogin());
            document.getElementById('showRegisterBtn').addEventListener('click', () => this.showScreen('registerScreen'));
            document.getElementById('showLoginBtn').addEventListener('click', () => this.showScreen('loginScreen'));
            document.getElementById('logoutBtn').addEventListener('click', () => this.logout());

            // Platform Connections
            document.querySelectorAll('.platform-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    const platform = e.currentTarget.dataset.platform;
                    this.showPlatformModal(platform);
                });
            });

            // Platform action buttons
            document.querySelectorAll('.connect-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const platform = e.target.dataset.platform;
                    this.showPlatformModal(platform);
                });
            });

            document.querySelectorAll('.disconnect-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const platform = e.target.dataset.platform;
                    this.disconnectPlatform(platform);
                });
            });

            // Bridge Login Handlers
            // document.getElementById('startWhatsAppLogin').addEventListener('click', () => this.startWhatsAppLogin());
            // WhatsApp method selection
document.getElementById('whatsappQRMethod').addEventListener('click', () => {
    this.startWhatsAppLogin('qr');
});

document.getElementById('whatsappPhoneMethod').addEventListener('click', () => {
    document.getElementById('whatsappQRInfo').classList.add('hidden');
    document.getElementById('whatsappPhoneInfo').classList.remove('hidden');
});

document.getElementById('startWhatsAppPhoneLogin').addEventListener('click', () => {
    const phoneNumber = document.getElementById('whatsappPhoneNumber').value;
    if (phoneNumber) {
        this.startWhatsAppLogin('phone', phoneNumber);
    } else {
        this.showToast('Please enter your phone number', 'error');
    }
});
            document.getElementById('startTelegramLogin').addEventListener('click', () => this.startTelegramLogin());
            document.getElementById('verifyTelegramCode').addEventListener('click', () => this.verifyTelegramCode());
            document.getElementById('startInstagramLogin').addEventListener('click', () => this.startInstagramLogin());
            document.getElementById('startTwitterLogin').addEventListener('click', () => this.startTwitterLogin());

            // Group Creation
            document.getElementById('createGroupBtn').addEventListener('click', () => this.showCreateGroupModal());
            document.getElementById('createGroup').addEventListener('click', () => this.createGroup());
            document.getElementById('searchUsers').addEventListener('input', (e) => this.searchUsers(e.target.value));

            // Manual Sync
            document.getElementById('manualSyncBtn').addEventListener('click', () => this.triggerManualSync());

            // Modal Closures
            document.querySelectorAll('.close-modal').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.target.closest('.modal').classList.add('hidden');
                });
            });

            // Reply system event listeners
            document.getElementById('cancelReplyBtn').addEventListener('click', () => this.cancelReply());
            
            // Context menu event listeners
            document.getElementById('replyContextItem').addEventListener('click', () => this.handleReplyFromContextMenu());
            document.getElementById('copyContextItem').addEventListener('click', () => this.handleCopyFromContextMenu());
            document.getElementById('deleteContextItem').addEventListener('click', () => this.handleDeleteFromContextMenu());
            
            // Close context menu when clicking elsewhere
            document.addEventListener('click', (e) => {
                const contextMenu = document.getElementById('messageContextMenu');
                if (contextMenu && !contextMenu.contains(e.target) && !e.target.closest('.message-bubble')) {
                    contextMenu.classList.remove('show');
                }
            });
            
        }

        initSocket() {
            this.socket.on('connect', () => {
                console.log('âœ… Connected to server');
                this.showToast('Connected to server', 'success');
                
                // Re-join user if logged in
                if (this.currentUser) {
                    this.socket.emit('join_user', this.currentUser.email);
                    // Request initial sync via WebSocket
                    this.socket.emit('request_sync', {
                        email: this.currentUser.email,
                        since: localStorage.getItem('last_sync_token')
                    });
                }
            });

            this.socket.on('disconnect', () => {
                this.showToast('Disconnected from server', 'error');
            });

            // NEW: Show sync status when sync starts
            this.socket.on('sync_started', (data) => {
                console.log('ðŸ”„ Sync started:', data);
                this.showSyncStatus(true);
            });

            this.socket.on('new_message', (data) => {
                this.handleNewMessage(data);
            });

            this.socket.on('message_sent', (data) => {
                this.handleMessageSent(data);
            });

            // REACTION EVENTS
            this.socket.on('reaction_added', (data) => {
                console.log('ðŸŽ¯ Reaction added event received:', data);
                this.handleReactionUpdate(data);
            });

            // WebSocket sync events
            this.socket.on('sync_update', (data) => {
                console.log('ðŸ”„ Real-time sync update:', data);
                this.handleSyncUpdate(data);
            });

            this.socket.on('sync_data', (data) => {
                console.log('ðŸ“¦ Complete sync data received:', data);
                this.handleCompleteSync(data);
            });

            this.socket.on('sync_complete', (data) => {
                console.log('âœ… Sync completed:', data);
                this.showSyncStatus(false);
                this.showToast('Sync completed successfully', 'success');
            });

            this.socket.on('sync_error', (error) => {
                console.error('âŒ Sync error:', error);
                this.showSyncStatus(false);
                this.showToast('Sync failed: ' + error.error, 'error');
            });

            this.socket.on('platform_status', (data) => {
                console.log('ðŸ”„ Platform status update:', data);
                this.updatePlatformStatus(data.platform, data.connected);
                if (data.connected) {
                    this.showToast(`${data.platform} connected successfully`, 'success');
                } else {
                    this.showToast(`${data.platform} disconnected`, 'info');
                }
            });

            this.socket.on('error', (error) => {
                console.error('Socket error:', error);
                this.showToast('Connection error: ' + error, 'error');
            });
        }

        // NEW: Show/hide sync status
        showSyncStatus(show) {
            this.isSyncing = show;
            const syncStatus = document.getElementById('syncStatus');
            if (syncStatus) {
                syncStatus.classList.toggle('hidden', !show);
            }
        }

        // UPDATED: Handle new message with proper platform detection
handleNewMessage(data) {
    console.log('New message received:', data);
    
    const roomId = data.room_id;
    const platform = data.platform;
    
    console.log(`ðŸ“¨ Message platform: ${platform} for room: ${roomId}`);
    
    // Determine if this is a supported platform or "others"
    const isSupportedPlatform = ['whatsapp', 'telegram', 'instagram', 'twitter', 'email', 'matrix'].includes(platform);
    const targetPlatform = isSupportedPlatform ? platform : 'others';
    
    console.log(`ðŸŽ¯ Target platform for UI: ${targetPlatform}`);
    
    // Get the appropriate room and message maps
    const roomMap = this.getRoomMap(targetPlatform);
    const msgMap = this.getMsgMap(targetPlatform);
    
    // Check if room already exists
    if (!roomMap.has(roomId)) {
        console.log(`ðŸ†• Creating new room for platform: ${targetPlatform}, room: ${roomId}`);
        
        // Create new room data
        const newRoom = {
            roomId: roomId,
            name: data.room_name || `Chat with ${data.sender_name || 'Unknown'}`,
            avatar: data.room_avatar || null,
            type: data.room_type || 'direct',
            platform: platform, // Keep original platform for reference
            platform_code: data.platform_code || platform,
            lastMsg: data.body || 'New message',
            lastMsgTimestamp: data.timestamp || Date.now(),
            unreadCount: 1
        };
        
        // Add to appropriate map
        roomMap.set(roomId, newRoom);
        
        // Initialize message array for this room
        msgMap.set(roomId, []);
        
        // Update UI
        this.renderAllSidebars();
        
        console.log(`âœ… New room created: ${newRoom.name} (${targetPlatform})`);
    } else {
        // Room exists, update it
        const existingRoom = roomMap.get(roomId);
        if (existingRoom) {
            existingRoom.lastMsg = data.body || 'New message';
            existingRoom.lastMsgTimestamp = data.timestamp || Date.now();
            
            // Increment unread count if not currently viewing this room
            if (!this.isRoomCurrentlyOpen(targetPlatform, roomId)) {
                existingRoom.unreadCount = (existingRoom.unreadCount || 0) + 1;
            }
            
            roomMap.set(roomId, existingRoom);
            this.renderAllSidebars();
        }
    }
    
    // Now handle the message display
    if (this.currentRoom && data.room_id === this.currentRoom.roomId) {
        this.appendMessageToUI({
            id: data.event_id,
            roomId: data.room_id,
            sender: data.sender,
            type: data.msgtype,
            content: {
                text: data.body,
                fileUrl: data.content?.fileUrl || data.content?.url
            },
            timestamp: data.timestamp,
            status: 'received',
            reply_to: data.reply_to
        });
        
        // Update room last message and move to top
        this.updateRoomLastMessage(data.room_id, data.body, data.timestamp);
    } else {
        // Message for a different room - update room preview with unread count
        this.handleMessageForOtherRoom(data);
    }
}
        // NEW: Render "Others" rooms section
        // UPDATED: Render "Others" rooms section with proper sorting
renderOthersRooms() {
    const othersSection = document.getElementById('othersSection');
    const othersRoomsList = document.getElementById('othersRoomsList');
    
    if (!othersSection || !othersRoomsList) return;
    
    // Clear existing others rooms
    othersRoomsList.innerHTML = '';
    
    // Get all others rooms
    const othersRoomsArray = Array.from(othersRooms.values());
    
    if (othersRoomsArray.length === 0) {
        othersSection.classList.add('hidden');
        return;
    }
    
    // Sort by timestamp (newest first) - handle undefined timestamps
    const sortedRooms = othersRoomsArray.sort((a, b) => {
        const timeA = a.lastMsgTimestamp || 0;
        const timeB = b.lastMsgTimestamp || 0;
        return timeB - timeA; // Descending order (newest first)
    });
    
    // Render each room
    sortedRooms.forEach(room => {
        const roomDiv = document.createElement('div');
        const isActive = this.currentRoom?.roomId === room.roomId && this.currentPlatform === 'others';
        const hasUnread = room.unreadCount > 0;
        
        roomDiv.className = `others-room-item ${isActive ? 'active' : ''}`;
        roomDiv.dataset.roomId = room.roomId;
        roomDiv.dataset.platform = 'others';
        
        const lastMessageTime = room.lastMsgTimestamp ? this.formatTime(room.lastMsgTimestamp) : '';
        const unreadBadge = room.unreadCount > 0 ? 
            `<div class="others-room-unread">${room.unreadCount}</div>` : '';

        roomDiv.innerHTML = `
            <div class="others-room-avatar">
                <i class="fas fa-comment-alt"></i>
            </div>
            <div class="others-room-details">
                <div class="others-room-name">${this.escapeHtml(room.name || 'Unknown')}</div>
                <div class="others-room-platform">${this.escapeHtml(room.platform)}</div>
            </div>
            <div class="others-room-meta">
                <div class="others-room-time">${lastMessageTime}</div>
                ${unreadBadge}
            </div>
        `;

        roomDiv.addEventListener('click', () => {
            console.log('Others room selected:', room);
            this.selectRoom(room, 'others');
        });
        
        othersRoomsList.appendChild(roomDiv);
    });
    
    othersSection.classList.remove('hidden');
    console.log(`âœ… Others rooms rendered: ${sortedRooms.length} rooms`);
}
        // UPDATED: Render all sidebars including others with proper sorting
renderAllSidebars() {
    const container = document.getElementById('roomsList');
    if (!container) {
        console.error('roomsList container not found!');
        return;
    }
    
    container.innerHTML = ""; 
    
    // Combine all rooms from all supported platforms
    const allRooms = [
        ...Array.from(whatsappRooms.values()),
        ...Array.from(telegramRooms.values()),
        ...Array.from(instagramRooms.values()),
        ...Array.from(twitterRooms.values()),
        ...Array.from(emailRooms.values())
    ];
    
    console.log('Total rooms to render:', allRooms.length);
    
    // Sort by timestamp (newest first) - handle undefined timestamps
    const sortedRooms = allRooms.sort((a, b) => {
        const timeA = a.lastMsgTimestamp || 0;
        const timeB = b.lastMsgTimestamp || 0;
        return timeB - timeA; // Descending order (newest first)
    });

    if (sortedRooms.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 20px; color: #666;">
                <i class="fas fa-comments" style="font-size: 2rem; margin-bottom: 10px;"></i>
                <p>No conversations yet</p>
                <small>Connect a platform to see conversations</small>
            </div>
        `;
    } else {
        sortedRooms.forEach(room => {
            const roomDiv = document.createElement("div");
            const isActive = this.currentRoom?.roomId === room.roomId && this.currentPlatform === room.platform;
            const hasUnread = room.unreadCount > 0;
            
            roomDiv.className = `room-item ${isActive ? 'active' : ''} ${hasUnread ? 'unread' : ''}`;
            roomDiv.dataset.roomId = room.roomId;
            roomDiv.dataset.platform = room.platform;
            
            const lastMessageTime = room.lastMsgTimestamp ? this.formatTime(room.lastMsgTimestamp) : '';
            const unreadBadge = room.unreadCount > 0 ? 
                `<div class="room-unread">${room.unreadCount}</div>` : '';

            // Platform icon
            const platformIcon = this.getPlatformIcon(room.platform);
            
            roomDiv.innerHTML = `
                <div class="room-avatar" style="background: ${this.getPlatformColor(room.platform)}">
                    <i class="${platformIcon}"></i>
                </div>
                <div class="room-details">
                    <div class="room-name">
                        ${this.escapeHtml(room.name || 'Unknown')}
                        ${hasUnread ? '<span style="color: var(--primary-color); font-size: 8px;">â—</span>' : ''}
                    </div>
                    <div class="room-last-message">${this.escapeHtml(room.lastMsg || 'No messages')}</div>
                </div>
                <div class="room-meta">
                    <div class="room-time">${lastMessageTime}</div>
                    ${unreadBadge}
                </div>
            `;

            roomDiv.addEventListener('click', () => {
                console.log('Room selected:', room);
                this.selectRoom(room, room.platform);
            });
            
            container.appendChild(roomDiv);
        });
    }
    
    // Render others rooms with proper sorting
    this.renderOthersRooms();
    
    console.log('Rooms rendered successfully with sorting');
}
// UPDATED: Enhanced AI Rephrase functionality
initializeAIRephrase() {
    console.log('ðŸ”„ Initializing AI Rephrase...');
    
    this.aiRephraseModal = document.getElementById('aiRephraseModal');
    this.originalText = document.getElementById('originalText');
    this.toneSelect = document.getElementById('toneSelect');
    this.customToneContainer = document.getElementById('customToneContainer');
    this.customTone = document.getElementById('customTone');
    this.cancelRephraseBtn = document.getElementById('cancelRephrase');
    this.confirmRephraseBtn = document.getElementById('confirmRephrase');
    
    console.log('ðŸ” Modal elements:', {
        modal: this.aiRephraseModal,
        originalText: this.originalText,
        toneSelect: this.toneSelect
    });
    
    // Event listeners
    this.toneSelect.addEventListener('change', (e) => {
        this.handleToneSelection(e.target.value);
    });
    
    this.cancelRephraseBtn.addEventListener('click', () => {
        this.hideAIRephraseModal();
    });
    
    this.confirmRephraseBtn.addEventListener('click', () => {
        this.performAIRephrase();
    });
    
    // Close modal events
    const closeBtn = this.aiRephraseModal.querySelector('.close-modal');
    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            this.hideAIRephraseModal();
        });
    }
    
    // Close modal when clicking outside
    this.aiRephraseModal.addEventListener('click', (e) => {
        if (e.target === this.aiRephraseModal) {
            this.hideAIRephraseModal();
        }
    });
    
    // AI Rephrase button event listener
    const aiRephraseBtn = document.getElementById('aiRephraseBtn');
    if (aiRephraseBtn) {
        aiRephraseBtn.addEventListener('click', () => {
            this.handleAIRephrase();
        });
    }
    
    console.log('âœ… AI Rephrase initialized');
}

// NEW: Handle tone selection
handleToneSelection(tone) {
    if (tone === 'other') {
        this.customToneContainer.classList.remove('hidden');
        this.customTone.focus();
    } else {
        this.customToneContainer.classList.add('hidden');
        this.customTone.value = '';
    }
}

// NEW: Hide AI rephrase modal
hideAIRephraseModal() {
    this.aiRephraseModal.classList.add('hidden');
}

// FIXED: Enhanced AI rephrase with proper data sending
async performAIRephrase() {
    const originalText = this.originalText.value.trim();
    const selectedTone = this.toneSelect.value;
    let customTone = this.customTone.value.trim();
    
    if (!originalText) {
        this.showToast('Please enter some text to rephrase', 'warning');
        return;
    }
    
    // Validate custom tone if "other" is selected
    if (selectedTone === 'other' && !customTone) {
        this.showToast('Please specify a custom tone', 'warning');
        this.customTone.focus();
        return;
    }
    
    // Determine final tone
    let finalTone = '';
    if (selectedTone && selectedTone !== 'other') {
        finalTone = selectedTone;
    } else if (customTone) {
        finalTone = customTone;
    }

    // Show loading state
    this.confirmRephraseBtn.disabled = true;
    this.confirmRephraseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Rephrasing...';
    
    try {
        // Prepare request data with ALL required fields
        const requestData = {
            text: originalText,
            tone: finalTone,
            user_email: this.currentUser?.email || 'user@example.com', // Fallback if no user
            room_id: this.currentRoom?.roomId || null, // Can be null if no room selected
            platform: this.currentPlatform || 'web',
            include_context: true
        };

        console.log('ðŸ“¤ Sending AI rephrase request:', requestData);

        const response = await fetch('/ai_rephrase', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('ðŸ“¥ AI rephrase response:', data);

        if (data.success) {
            // Replace the text in the input with the AI rephrased version
            this.messageInput.value = data.rephrased_text;
            this.adjustTextareaHeight(this.messageInput);
            this.toggleSendButton();
            this.updateCharCounter();
            
            this.hideAIRephraseModal();
            
            const toneMessage = finalTone ? ` in ${finalTone} tone` : '';
            this.showToast(`Text rephrased with AI${toneMessage}! Review and click send.`, 'success');
            
            // Focus on the input so user can edit or send immediately
            this.messageInput.focus();
            
        } else {
            this.showToast(data.error || 'Failed to rephrase text', 'error');
        }
    } catch (error) {
        console.error('AI rephrase error:', error);
        this.showToast('Failed to connect to AI service: ' + error.message, 'error');
    } finally {
        // Reset button state
        this.confirmRephraseBtn.disabled = false;
        this.confirmRephraseBtn.innerHTML = '<i class="fas fa-magic"></i> Rephrase';
    }
}
// UPDATED: Handle AI rephrase button click// FIXED: Handle AI rephrase button click - Ensure modal shows
handleAIRephrase() {
    console.log('ðŸŽ¯ AI Rephrase button clicked!');
    
    // Check if we have the necessary elements
    if (!this.messageInput) {
        console.error('âŒ Message input not found');
        this.showToast('Message input not available', 'error');
        return;
    }
    
    const originalText = this.messageInput.value.trim();
    console.log('ðŸ“ Original text:', originalText);
    
    if (!originalText) {
        this.showToast('Please enter some text to rephrase', 'warning');
        return;
    }
    
    // Show the modal
    this.showAIRephraseModal();
}
hideAIRephraseModal() {
    const modal = document.getElementById('aiRephraseModal');
    if (modal) {
        modal.classList.add('hidden');
        console.log('âœ… AI Rephrase modal hidden');
    }
}
showAIRephraseModal() {
    console.log('ðŸ”„ Showing AI Rephrase Modal...');
    
    const modal = document.getElementById('aiRephraseModal');
    if (!modal) {
        console.error('âŒ AI Rephrase modal not found in DOM');
        this.showToast('AI rephrase feature not available', 'error');
        return;
    }
    
    // Set original text
    if (this.messageInput) {
        const originalText = this.messageInput.value.trim();
        this.originalText.value = originalText;
        console.log('ðŸ“‹ Set original text in modal:', originalText);
    }
    
    // Reset form
    this.toneSelect.value = '';
    this.customToneContainer.classList.add('hidden');
    this.customTone.value = '';
    
    // SHOW THE MODAL - Remove hidden class
    modal.classList.remove('hidden');
    
    // Add to body if not already there (ensure it's at root level)
    if (!document.body.contains(modal)) {
        document.body.appendChild(modal);
    }
    
    console.log('âœ… Modal should be visible now');
    
    // Force focus and ensure visibility
    setTimeout(() => {
        modal.style.display = 'flex';
        modal.style.visibility = 'visible';
        modal.style.opacity = '1';
    }, 10);
}
        // UPDATED: Select room with platform parameter
        async selectRoom(room, platform) {
            console.log('Selecting room:', room, 'Platform:', platform);
            
            this.currentRoom = room;
            this.currentPlatform = platform;
            
            // Mark room as read when selected
            if (room.unreadCount > 0) {
                room.unreadCount = 0;
                this.updateRoomInMap(platform, room.roomId, room);
            }
            
            // Update UI to show this room as active
            this.renderAllSidebars();
            
            // Update chat header
            document.getElementById('chatRoomName').textContent = room.name || 'Unknown';
            document.getElementById('chatRoomStatus').textContent = `${platform} â€¢ ${room.type || 'chat'}`;
            
            // Show chat area
            document.getElementById('noChatSelected').classList.add('hidden');
            document.getElementById('activeChat').classList.remove('hidden');
            
            // Clear any existing messages
            document.getElementById('messagesList').innerHTML = '<div class="loading-message">Loading messages...</div>';
            
            // Load messages for this room
            await this.openMsgRoom(platform, room.roomId);
        }

        // UPDATED: Open message room for any platform including others
        async openMsgRoom(platform, roomId) {
            console.log(`Opening messages for ${platform} room: ${roomId}`);
            
            try {
                console.log('Getting message map for platform:', platform);
                const msgMap = this.getMsgMap(platform);
                console.log('Message map retrieved:', msgMap);
                
                const response = await fetch('/api/getRoomMessages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        room_id: roomId,
                        user_email: this.currentUser.email
                    })
                });

                const data = await response.json();
                console.log('Room messages response:', data);

                if (data.success) {
                    const messages = data.messages.map(msg => {
                        // Use the correct field names from API response
                        const messageData = {
                            id: msg.event_id,
                            roomId: roomId,
                            sender: msg.sender_id,
                            senderName: msg.sender_name,
                            senderAvatar: msg.sender_avatar,
                            type: msg.type || msg.msgtype,
                            body: msg.body,
                            content: {
                                text: msg.body,
                                fileUrl: msg.content?.url,
                                fileName: msg.content?.body
                            },
                            timestamp: msg.timestamp || msg.origin_server_ts,
                            status: 'sent'
                        };
                        
                        // Handle reactions properly
                        if (msg.reactions && Array.isArray(msg.reactions)) {
                            console.log(`ðŸ“¥ Message ${msg.event_id} has ${msg.reactions.length} reactions:`, msg.reactions);
                            messageData.reactions = msg.reactions.map(reaction => ({
                                emoji: reaction.emoji || reaction.key,
                                count: reaction.count || 1,
                                senders: reaction.senders || [reaction.sender] || []
                            }));
                        } else {
                            messageData.reactions = [];
                        }
                        
                        // Handle reply_to data
                        if (msg.reply_to) {
                            messageData.reply_to = {
                                id: msg.reply_to.id,
                                sender: msg.reply_to.sender,
                                content: msg.reply_to.content
                            };
                        }
                        
                        return messageData;
                    });

                    messages.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                    
                    msgMap.set(roomId, messages);
                    this.renderRoomMessages(platform, roomId);
                    this.maintainMsgCache(msgMap, 10);
                    
                } else {
                    console.error('Failed to load messages:', data.error);
                    this.showToast('Failed to load messages', 'error');
                }
            } catch(err) {
                console.error('Error loading messages:', err);
                this.showToast('Failed to load messages', 'error');
            }
        }

        // UPDATED: Get room map for any platform including others
        getRoomMap(platform) {
            // Ensure consistent platform name format
            const platformNormalized = platform.charAt(0).toUpperCase() + platform.slice(1).toLowerCase();
            
            switch (platformNormalized) {
                case "Whatsapp": return whatsappRooms;
                case "Telegram": return telegramRooms;
                case "Instagram": return instagramRooms;
                case "Twitter": return twitterRooms;
                case "Email": return emailRooms;
                case "Others": return othersRooms;
                default: 
                    console.error('Invalid platform:', platform);
                    throw new Error(`Invalid platform: ${platform}`);
            }
        }

        // UPDATED: Get message map for any platform including others
        getMsgMap(platform) {
            // Ensure consistent platform name format
            const platformNormalized = platform.charAt(0).toUpperCase() + platform.slice(1).toLowerCase();
            
            switch (platformNormalized) {
                case "Whatsapp": return msgWhatsappMap;
                case "Telegram": return msgTelegramMap;
                case "Instagram": return msgInstagramMap;
                case "Twitter": return msgTwitterMap;
                case "Email": return msgEmailMap;
                case "Others": return msgOthersMap;
                default: 
                    console.error('Invalid platform:', platform);
                    throw new Error(`Invalid platform: ${platform}`);
            }
        }

        // UPDATED: Handle message for other room including others
        // UPDATED: Handle message for other room including others
handleMessageForOtherRoom(messageData) {
    const { room_id, body, timestamp, sender, platform } = messageData;
    
    console.log(`ðŸ“¨ Message for other room: ${room_id}, platform: ${platform}`);
    
    // Determine if this is a supported platform or "others"
    const isSupportedPlatform = ['whatsapp', 'telegram', 'instagram', 'twitter', 'email'].includes(platform);
    const targetPlatform = isSupportedPlatform ? platform : 'others';
    
    // Get the appropriate room map
    const roomMap = this.getRoomMap(targetPlatform);
    const room = roomMap.get(room_id);
    
    if (room) {
        // Update room metadata
        room.lastMsg = body || 'New message';
        room.lastMsgTimestamp = timestamp || Date.now();
        
        // Increment unread count if not currently viewing this room
        if (!this.isRoomCurrentlyOpen(targetPlatform, room_id)) {
            room.unreadCount = (room.unreadCount || 0) + 1;
            console.log(`ðŸ”” Unread count increased for ${room.name}: ${room.unreadCount}`);
        }
        
        roomMap.set(room_id, room);
        
        // Update UI and re-sort rooms
        this.updateRoomInSidebar(targetPlatform, room_id, room);
        
        console.log(`ðŸ”„ Updated room preview for ${room.name}: ${body ? body.substring(0, 30) + '...' : 'New message'}`);
    } else {
        console.log(`âŒ Room ${room_id} not found in ${targetPlatform} map`);
    }
}

// NEW: Update room in sidebar UI
updateRoomInSidebar(platform, roomId, roomData) {
    // Update the room in the appropriate map
    const roomMap = this.getRoomMap(platform);
    roomMap.set(roomId, roomData);
    
    // Re-render the entire sidebar to ensure proper sorting
    this.renderAllSidebars();
    
    console.log(`âœ… Sidebar updated for room: ${roomData.name}`);
}

// UPDATED: Check if room is currently open for any platform
isRoomCurrentlyOpen(platform, roomId) {
    const isOpen = this.currentRoom && 
                   this.currentRoom.roomId === roomId && 
                   this.currentPlatform === platform;
    
    console.log(`ðŸ” Room ${roomId} currently open: ${isOpen}`);
    return isOpen;
}

        // UPDATED: Check if room is currently open for any platform
        isRoomCurrentlyOpen(platform, roomId) {
            return this.currentRoom && 
                   this.currentRoom.roomId === roomId && 
                   this.currentPlatform === platform;
        }

        // UPDATED: Update room in map for any platform
        updateRoomInMap(platform, roomId, roomData) {
            const roomMap = this.getRoomMap(platform);
            roomMap.set(roomId, roomData);
            this.renderAllSidebars();
        }

        // UPDATED: Update room last message for any platform
        // UPDATED: Update room last message for any platform
updateRoomLastMessage(roomId, message, timestamp) {
    // Determine which platform this room belongs to
    let platform = this.getPlatformByRoomId(roomId);
    if (!platform) {
        console.warn(`Room ${roomId} not found in any platform map`);
        return;
    }
    
    const roomMap = this.getRoomMap(platform);
    const room = roomMap.get(roomId);
    if (room) {
        room.lastMsg = message || 'New message';
        room.lastMsgTimestamp = timestamp || Date.now();
        roomMap.set(roomId, room);
        
        // Update the sidebar UI
        this.renderAllSidebars();
        
        console.log(`ðŸ”„ Room last message updated: ${room.name}`);
    }
}

        // UPDATED: Get platform by room ID including others
        getPlatformByRoomId(roomId) {
            if (whatsappRooms.has(roomId)) return "whatsapp";
            if (telegramRooms.has(roomId)) return "telegram";
            if (instagramRooms.has(roomId)) return "instagram";
            if (twitterRooms.has(roomId)) return "twitter";
            if (emailRooms.has(roomId)) return "email";
            if (othersRooms.has(roomId)) return "others";
            
            console.warn('Room not found in any platform map:', roomId);
            return null;
        }

        // UPDATED: Fetch joined rooms including others
        async fetchedJoinedRooms() {
            try {
                const response = await fetch('/api/get_rooms', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: this.currentUser.email })
                });

                const data = await response.json();
                console.log('Fetched rooms:', data);
                
                if (data.success) {
                    // Clear existing rooms
                    whatsappRooms.clear();
                    telegramRooms.clear();
                    instagramRooms.clear();
                    twitterRooms.clear();
                    emailRooms.clear();
                    othersRooms.clear();
                    
                    data.rooms.forEach(room => {
                        const roomData = {
                            roomId: room.roomId,
                            name: room.name,
                            avatar: room.avatar,
                            type: room.type,
                            platform: room.platform,
                            platform_code: room.platform_code,
                            lastMsg: room.last_message,
                            lastMsgTimestamp: room.last_message_ts,
                            unreadCount: room.unread_count || 0
                        };

                        console.log(`Adding room: ${room.name} (${room.platform})`);

                        // Determine if this is a supported platform or "others"
                        const isSupportedPlatform = ['whatsapp', 'telegram', 'instagram', 'twitter', 'email'].includes(room.platform.toLowerCase());
                        const targetPlatform = isSupportedPlatform ? room.platform.toLowerCase() : 'others';

                        switch(targetPlatform) {
                            case 'whatsapp':
                                whatsappRooms.set(room.roomId, roomData);
                                break;
                            case 'telegram':
                                telegramRooms.set(room.roomId, roomData);
                                break;
                            case 'instagram':
                                instagramRooms.set(room.roomId, roomData);
                                break;
                            case 'twitter':
                                twitterRooms.set(room.roomId, roomData);
                                break;
                            case 'email':
                                emailRooms.set(room.roomId, roomData);
                                break;
                            case 'others':
                                othersRooms.set(room.roomId, roomData);
                                break;
                            default:
                                console.warn('Unknown platform:', room.platform);
                        }
                    });
                    
                    this.renderAllSidebars();
                } else {
                    console.error('Failed to fetch rooms:', data.error);
                    this.showToast('Failed to load conversations', 'error');
                }
            } catch(err) {
                console.error('Error fetching rooms:', err);
                this.showToast('Failed to load conversations', 'error');
            }
        }

        // UPDATED: Handle login success with sync status
        handleLoginSuccess(data, email) {
            this.currentUser = {
                email,
                matrix_access_token: data.matrix_access_token,
                device_id: data.device_id
            };

            // Store in localStorage
            localStorage.setItem('matrix_access_token', data.matrix_access_token);
            localStorage.setItem('user_email', email);
            localStorage.setItem('device_id', data.device_id);

            // Update UI
            document.getElementById('userEmail').textContent = email;
            this.showScreen('appScreen');
            
            // Show sync status
            this.showSyncStatus(true);
            
            // Join user room and request sync via WebSocket
            this.socket.emit('join_user', email);
            this.socket.emit('request_sync', {
                email: email,
                since: localStorage.getItem('last_sync_token')
            });
            
            // Load initial data
            this.fetchedJoinedRooms();
            this.showToast('Login successful!', 'success');
        }

        // All other methods remain the same as in the previous code
        // ... (all the other methods from the previous code) ...

        // Authentication Methods
        async login() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                this.showToast('Please fill in all fields', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();

                if (data.success) {
                    this.handleLoginSuccess(data, email);
                } else {
                    this.showToast(data.error || 'Login failed', 'error');
                }
            } catch (error) {
                this.showToast('Login failed. Please try again.', 'error');
                console.error('Login error:', error);
            } finally {
                this.showLoading(false);
            }
        }

        async register() {
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;

            if (!email || !password) {
                this.showToast('Please fill in all fields', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();

                if (data.success) {
                    this.handleLoginSuccess(data, email);
                    this.showToast('Registration successful!', 'success');
                } else {
                    this.showToast(data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                this.showToast('Registration failed. Please try again.', 'error');
                console.error('Registration error:', error);
            } finally {
                this.showLoading(false);
            }
        }

        async googleLogin() {
            this.showToast('Google login would be implemented with proper OAuth flow', 'info');
        }

        async logout() {
            try {
                if (this.currentUser) {
                    await fetch('/logout', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: this.currentUser.email })
                    });
                }
            } catch (error) {
                console.error('Logout error:', error);
            }

            // Clear local storage
            localStorage.clear();
            this.currentUser = null;
            this.currentRoom = null;
            this.currentPlatform = null;
            whatsappRooms.clear();
            telegramRooms.clear();
            instagramRooms.clear();
            twitterRooms.clear();
            emailRooms.clear();
            othersRooms.clear();
            msgWhatsappMap.clear();
            msgTelegramMap.clear();
            msgInstagramMap.clear();
            msgTwitterMap.clear();
            msgEmailMap.clear();
            msgOthersMap.clear();

            // Reset UI
            this.showScreen('loginScreen');
            document.getElementById('loginEmail').value = '';
            document.getElementById('loginPassword').value = '';
            document.getElementById('activeChat').classList.add('hidden');
            document.getElementById('noChatSelected').classList.remove('hidden');
            
            this.showToast('Logged out successfully', 'success');
        }

        // Bridge Login Methods
        showPlatformModal(platform) {
            const modalId = `${platform}Modal`;
            document.getElementById(modalId).classList.remove('hidden');
        }

        // UPDATED: WhatsApp login with method selection
// UPDATED: Enhanced WhatsApp login with better QR code display
// UPDATED: Enhanced WhatsApp login with robust QR code handling
async startWhatsAppLogin(method = 'qr', phoneNumber = null) {
    if (!this.currentUser) {
        this.showToast('Please login first', 'error');
        return;
    }

    this.showLoading(true);
    
    // Reset and show QR container
    this.resetQRContainer();
    
    try {
        const response = await fetch('/login/whatsapp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                email: this.currentUser.email, 
                method: method,
                phoneNumber: phoneNumber 
            })
        });

        const data = await response.json();
        console.log('WhatsApp login response:', data);

        if (data.success) {
            this.handleWhatsAppResponse(data);
        } else {
            this.showQRStatus(data.error || 'WhatsApp login failed', 'error');
        }
    } catch (error) {
        console.error('WhatsApp login error:', error);
        this.showQRStatus('WhatsApp login failed: ' + error.message, 'error');
    } finally {
        this.showLoading(false);
    }
}

// NEW: Handle different WhatsApp response types
handleWhatsAppResponse(data) {
    const qrInfo = document.getElementById('whatsappQRInfo');
    const phoneInfo = document.getElementById('whatsappPhoneInfo');
    
    qrInfo.classList.remove('hidden');
    phoneInfo.classList.add('hidden');

    switch(data.type) {
        case "qr_image":
            // Direct image from bridge
            this.displayQRCodeImage(data.qrImageUrl, 'WhatsApp QR Code');
            this.showQRStatus('QR code loaded. Please scan with WhatsApp.', 'success');
            break;
            
        case "qr_generated":
            // Generated QR code from URL/data
            this.displayQRCodeImage(data.qrImageUrl, 'WhatsApp QR Code');
            this.showQRStatus('QR code generated. Please scan with WhatsApp.', 'success');
            break;
            
        case "qr_direct_link":
            // Show direct link
            this.displayQRCodeFallback(data.qrUrl, 'direct');
            this.showQRStatus('Click the link above to connect WhatsApp.', 'info');
            break;
            
        case "qr_instructions":
            // Show instructions
            this.displayQRCodeFallback(data.instructions, 'instructions');
            this.showQRStatus('Please follow the instructions above.', 'warning');
            break;
            
        case "phone_request":
            // Switch to phone input
            qrInfo.classList.add('hidden');
            phoneInfo.classList.remove('hidden');
            this.showQRStatus('Please enter your phone number', 'info');
            break;
            
        case "code_received":
            this.showQRStatus(`Verification code: <strong>${data.code}</strong>`, 'info');
            break;
            
        case "already_connected":
            this.showQRStatus(data.message, 'success');
            this.updatePlatformStatus('whatsapp', true);
            setTimeout(() => {
                document.getElementById('whatsappModal').classList.add('hidden');
                this.fetchedJoinedRooms();
            }, 3000);
            break;
            
        default:
            this.showQRStatus(data.message || 'Login initiated successfully', 'info');
    }
    
    this.updatePlatformStatus('whatsapp', true);
}

// NEW: Reset QR container
resetQRContainer() {
    const qrImageContainer = document.getElementById('qrImageContainer');
    const qrLoading = document.getElementById('qrLoading');
    const qrFallback = document.getElementById('qrFallback');
    const qrStatus = document.getElementById('qrStatus');
    
    qrImageContainer.innerHTML = '';
    qrLoading.style.display = 'none';
    qrFallback.style.display = 'none';
    qrStatus.style.display = 'none';
    
    // Show loading initially
    qrLoading.style.display = 'block';
}

// NEW: Enhanced QR code image display
displayQRCodeImage(imageUrl, altText = 'WhatsApp QR Code') {
    const qrImageContainer = document.getElementById('qrImageContainer');
    const qrLoading = document.getElementById('qrLoading');
    const qrFallback = document.getElementById('qrFallback');
    
    qrLoading.style.display = 'none';
    qrImageContainer.innerHTML = '';
    
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = altText;
    img.style.maxWidth = '100%';
    img.style.height = 'auto';
    img.style.border = '2px solid #e1e5e9';
    img.style.borderRadius = '12px';
    img.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
    img.style.background = 'white';
    img.style.padding = '10px';
    
    // Add retry functionality for failed images
    let retryCount = 0;
    const maxRetries = 2;
    
    img.onerror = () => {
        retryCount++;
        console.error(`âŒ Failed to load QR image (attempt ${retryCount}):`, imageUrl);
        
        if (retryCount <= maxRetries) {
            // Add cache busting and retry
            const retryUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + `t=${Date.now()}`;
            console.log(`ðŸ”„ Retrying with URL: ${retryUrl}`);
            img.src = retryUrl;
        } else {
            this.displayQRCodeFallback('QR code image failed to load. Please try phone login method.', 'error');
        }
    };
    
    img.onload = () => {
        console.log('âœ… QR code image loaded successfully');
        this.showQRStatus('QR code loaded successfully. Please scan it with WhatsApp.', 'success');
    };
    
    qrImageContainer.appendChild(img);
}

// NEW: Enhanced fallback display
displayQRCodeFallback(content, type = 'error') {
    const qrImageContainer = document.getElementById('qrImageContainer');
    const qrLoading = document.getElementById('qrLoading');
    const qrFallback = document.getElementById('qrFallback');
    const qrFallbackContent = document.getElementById('qrFallbackContent');
    
    qrLoading.style.display = 'none';
    qrImageContainer.innerHTML = '';
    qrFallback.style.display = 'block';
    
    let fallbackHTML = '';
    
    switch(type) {
        case 'direct':
            fallbackHTML = `
                <div style="text-align: center; padding: 20px;">
                    <i class="fas fa-link" style="font-size: 48px; color: var(--primary-color); margin-bottom: 15px;"></i>
                    <p><strong>Alternative Connection Method:</strong></p>
                    <a href="${content}" target="_blank" 
                       style="display: inline-block; padding: 10px 15px; background: var(--primary-color); color: white; 
                              text-decoration: none; border-radius: 6px; margin: 10px 0; word-break: break-all;">
                       <i class="fas fa-external-link-alt"></i> Open WhatsApp Link
                    </a>
                    <p style="font-size: 14px; color: #666; margin-top: 10px;">
                        Click the button above to connect your WhatsApp account
                    </p>
                </div>
            `;
            break;
            
        case 'instructions':
            fallbackHTML = `
                <div style="text-align: left; padding: 15px;">
                    <i class="fas fa-info-circle" style="color: var(--warning-color); margin-right: 8px;"></i>
                    <strong>Bridge Instructions:</strong>
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-top: 10px; font-size: 14px;">
                        ${content}
                    </div>
                </div>
            `;
            break;
            
        default:
            fallbackHTML = `
                <div style="text-align: center; padding: 20px;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 48px; color: var(--warning-color); margin-bottom: 15px;"></i>
                    <p>${content}</p>
                    <button onclick="app.startWhatsAppLogin('phone')" 
                            style="padding: 10px 20px; background: var(--primary-color); color: white; 
                                   border: none; border-radius: 6px; cursor: pointer; margin-top: 10px;">
                        <i class="fas fa-phone"></i> Try Phone Login Instead
                    </button>
                </div>
            `;
    }
    
    qrFallbackContent.innerHTML = fallbackHTML;
}

// NEW: Show status in QR container
showQRStatus(message, type = 'info') {
    const qrStatus = document.getElementById('qrStatus');
    qrStatus.innerHTML = message;
    qrStatus.className = `qr-status ${type}`;
    qrStatus.style.display = 'block';
    
    // Also show toast for important messages
    if (type === 'error' || type === 'success') {
        this.showToast(message.replace(/<[^>]*>/g, ''), type); // Remove HTML tags for toast
    }
}
// NEW: Reset modal when opening
showPlatformModal(platform) {
    const modalId = `${platform}Modal`;
    const modal = document.getElementById(modalId);
    
    // Reset modal state
    if (platform === 'whatsapp') {
        document.getElementById('whatsappQRInfo').classList.add('hidden');
        document.getElementById('whatsappPhoneInfo').classList.add('hidden');
        document.getElementById('whatsappStatus').classList.add('hidden');
        document.getElementById('whatsappPhoneNumber').value = '';
    }
    
    modal.classList.remove('hidden');
}
        async startTelegramLogin() {
            if (!this.currentUser) {
                this.showToast('Please login first', 'error');
                return;
            }

            const phone = document.getElementById('telegramPhone').value;
            if (!phone) {
                this.showToast('Please enter your phone number', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/login/telegram', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        email: this.currentUser.email,
                        phoneNumber: phone
                    })
                });

                const data = await response.json();

                if (data.success) {
                    if (data.type === 'code_request') {
                        // Store the session ID for verification
                        this.platformSessions.set('telegram', data.sessionId);
                        document.getElementById('telegramStep1').classList.add('hidden');
                        document.getElementById('telegramStep2').classList.remove('hidden');
                        this.showToast('Verification code sent to your Telegram', 'success');
                    } else {
                        this.showToast(data.message, 'success');
                    }
                } else {
                    this.showToast(data.error, 'error');
                }
            } catch (error) {
                console.error('Telegram login error:', error);
                this.showToast('Telegram login failed', 'error');
            } finally {
                this.showLoading(false);
            }
        }

        async verifyTelegramCode() {
            const sessionId = this.platformSessions.get('telegram');
            const code = document.getElementById('telegramCode').value;

            if (!sessionId || !code) {
                this.showToast('Please enter the verification code', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/verify/telegram', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        sessionId: sessionId, 
                        code: code 
                    })
                });

                const data = await response.json();

                if (data.success) {
                    this.showToast(data.message, 'success');
                    // Close modal and update status
                    setTimeout(() => {
                        document.getElementById('telegramModal').classList.add('hidden');
                        this.updatePlatformStatus('telegram', true);
                        this.fetchedJoinedRooms();
                        // Reset the form
                        document.getElementById('telegramStep1').classList.remove('hidden');
                        document.getElementById('telegramStep2').classList.add('hidden');
                        document.getElementById('telegramPhone').value = '';
                        document.getElementById('telegramCode').value = '';
                    }, 2000);
                } else {
                    this.showToast(data.error || data.message, 'error');
                }
            } catch (error) {
                console.error('Telegram verification error:', error);
                this.showToast('Telegram verification failed', 'error');
            } finally {
                this.showLoading(false);
            }
        }

        async startInstagramLogin() {
            if (!this.currentUser) {
                this.showToast('Please login first', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/login/instagram', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: this.currentUser.email })
                });

                const data = await response.json();

                if (data.success) {
                    this.showToast(data.message, 'success');
                    document.getElementById('instagramStatus').classList.remove('hidden');
                    this.updatePlatformStatus('instagram', true);
                    this.fetchedJoinedRooms();
                } else {
                    this.showToast(data.error, 'error');
                }
            } catch (error) {
                console.error('Instagram login error:', error);
                this.showToast('Instagram login failed', 'error');
            } finally {
                this.showLoading(false);
            }
        }

        async startTwitterLogin() {
            if (!this.currentUser) {
                this.showToast('Please login first', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/login/twitter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: this.currentUser.email })
                });

                const data = await response.json();

                if (data.success) {
                    this.showToast(data.message, 'success');
                    document.getElementById('twitterStatus').classList.remove('hidden');
                    this.updatePlatformStatus('twitter', true);
                    this.fetchedJoinedRooms();
                } else {
                    this.showToast(data.error, 'error');
                }
            } catch (error) {
                console.error('Twitter login error:', error);
                this.showToast('Twitter login failed', 'error');
            } finally {
                this.showLoading(false);
            }
        }

        // NEW: Disconnect platform
        async disconnectPlatform(platform) {
            if (!this.currentUser) {
                this.showToast('Please login first', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/disconnect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        email: this.currentUser.email,
                        platform: platform
                    })
                });

                const data = await response.json();

                if (data.success) {
                    this.showToast(`${platform} disconnected successfully`, 'success');
                    this.updatePlatformStatus(platform, false);
                    
                    // Clear rooms for this platform
                    const roomMap = this.getRoomMap(platform);
                    roomMap.clear();
                    
                    // Clear messages for this platform
                    const msgMap = this.getMsgMap(platform);
                    msgMap.clear();
                    
                    // Refresh the sidebar
                    this.renderAllSidebars();
                    
                    // If current room is from this platform, close it
                    if (this.currentPlatform === platform) {
                        this.currentRoom = null;
                        this.currentPlatform = null;
                        document.getElementById('activeChat').classList.add('hidden');
                        document.getElementById('noChatSelected').classList.remove('hidden');
                    }
                } else {
                    this.showToast(data.error || `Failed to disconnect ${platform}`, 'error');
                }
            } catch (error) {
                console.error(`Disconnect ${platform} error:`, error);
                this.showToast(`Failed to disconnect ${platform}`, 'error');
            } finally {
                this.showLoading(false);
            }
        }

        updatePlatformStatus(platform, connected) {
            const platformCard = document.querySelector(`[data-platform="${platform}"]`);
            if (!platformCard) return;
            
            const statusElement = platformCard.querySelector('.platform-status');
            if (!statusElement) return;
            
            statusElement.classList.remove('connected', 'disconnected');
            statusElement.classList.add(connected ? 'connected' : 'disconnected');
            
            // Update action buttons
            const connectBtn = platformCard.querySelector('.connect-btn');
            const disconnectBtn = platformCard.querySelector('.disconnect-btn');
            
            if (connectBtn && disconnectBtn) {
                if (connected) {
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = 'block';
                } else {
                    connectBtn.style.display = 'block';
                    disconnectBtn.style.display = 'none';
                }
            }
        }

        // Group Management
        showCreateGroupModal() {
            document.getElementById('createGroupModal').classList.remove('hidden');
        }

        async searchUsers(query) {
            if (!query || !this.currentUser) return;

            try {
                const response = await fetch('/search-user', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        email: this.currentUser.email,
                        search_term: query
                    })
                });

                const data = await response.json();

                if (data.success) {
                    this.renderSearchResults(data.results);
                }
            } catch (error) {
                console.error('Error searching users:', error);
            }
        }

        renderSearchResults(users) {
            const resultsContainer = document.getElementById('searchResults');
            if (!resultsContainer) return;
            
            resultsContainer.innerHTML = '';

            users.forEach(user => {
                const userElement = document.createElement('div');
                userElement.className = 'search-result-item';
                userElement.innerHTML = `
                    <div class="user-avatar-small">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="user-details">
                        <div class="user-name">${user.user_id}</div>
                    </div>
                    <button class="btn-add-user" onclick="app.addUserToGroup('${user.user_id}')">
                        <i class="fas fa-plus"></i>
                    </button>
                `;
                resultsContainer.appendChild(userElement);
            });
        }

        addUserToGroup(userId) {
            const selectedContainer = document.getElementById('selectedMembers');
            if (!selectedContainer) return;
            
            const userElement = document.createElement('div');
            userElement.className = 'selected-member';
            userElement.innerHTML = `
                <span>${userId}</span>
                <button onclick="this.parentElement.remove()">&times;</button>
            `;
            selectedContainer.appendChild(userElement);
        }

        async createGroup() {
            const groupName = document.getElementById('groupName').value;
            const selectedMembers = Array.from(document.querySelectorAll('.selected-member span'))
                .map(span => span.textContent);

            if (!groupName || selectedMembers.length === 0) {
                this.showToast('Please enter group name and select members', 'error');
                return;
            }

            this.showLoading(true);

            try {
                const response = await fetch('/create-group', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        creator_email: this.currentUser.email,
                        group_name: groupName,
                        members: selectedMembers
                    })
                });

                const data = await response.json();

                if (data.success) {
                    document.getElementById('createGroupModal').classList.add('hidden');
                    this.showToast('Group created successfully!', 'success');
                    this.fetchedJoinedRooms();
                } else {
                    this.showToast(data.error, 'error');
                }
            } catch (error) {
                console.error('Error creating group:', error);
                this.showToast('Failed to create group', 'error');
            } finally {
                this.showLoading(false);
            }
        }

        // Real-time Handlers
        handleMessageSent(data) {
            console.log('Message sent confirmation:', data);
            // You can update UI to show message as delivered if needed
        }

        // WebSocket Sync Handlers
        handleCompleteSync(data) {
            if (data.success && data.data) {
                // Store the sync token for next request
                if (data.data.next_batch) {
                    localStorage.setItem('last_sync_token', data.data.next_batch);
                }
                
                // Process the structured sync data
                this.processSyncData(data.data);
            }
        }

        processSyncData(syncData) {
            const { platforms, next_batch } = syncData;
            
            // Process messages from all platforms
            Object.keys(platforms).forEach(platform => {
                const messages = platforms[platform];
                messages.forEach(message => {
                    this.handleIncomingMessage(message, platform);
                });
            });
            
            console.log(`ðŸ”„ Processed sync data with ${Object.keys(platforms).length} platforms`);
        }

        handleSyncUpdate(data) {
            console.log('ðŸ”„ Sync update received:', data);
            
            if (data.type === 'message') {
                this.handleIncomingMessage(data, data.platform);
            } else if (data.type === 'reaction') {
                this.handleReactionUpdate(data);
            } else if (data.type === 'manual_sync_complete') {
                this.showToast(data.message, 'success');
            }
        }

        handleIncomingMessage(msgEvent, platform) {
            const roomId = msgEvent.room_id;

            // Check if this message is for the currently open room
            if (this.isRoomCurrentlyOpen(platform, roomId)) {
                // Add message to UI immediately
                this.appendMessageToUI({
                    id: msgEvent.event_id,
                    roomId: roomId,
                    sender: msgEvent.sender,
                    type: msgEvent.msgtype,
                    content: {
                        text: msgEvent.body,
                        fileUrl: msgEvent.content?.url
                    },
                    timestamp: msgEvent.timestamp,
                    status: 'received',
                    // NEW: Handle reply data
                    reply_to: msgEvent.reply_to
                });
                
                // Update room last message and move to top
                this.updateRoomLastMessage(roomId, msgEvent.body, msgEvent.timestamp);
            } else {
                // Message for a different room - update room preview with unread count
                this.handleMessageForOtherRoom({
                    room_id: roomId,
                    body: msgEvent.body,
                    timestamp: msgEvent.timestamp,
                    sender: msgEvent.sender,
                    platform: platform
                });
            }

            // Update message map for the room
            const msgMap = this.getMsgMap(platform);
            const existingMsgs = msgMap.get(roomId) || [];
            
            const newMessage = {
                id: msgEvent.event_id,
                roomId: roomId,
                sender: msgEvent.sender,
                type: msgEvent.msgtype,
                content: {
                    text: msgEvent.body,
                    fileUrl: msgEvent.content?.url
                },
                timestamp: msgEvent.timestamp,
                status: 'sent',
                // NEW: Handle reply data
                reply_to: msgEvent.reply_to
            };
            
            existingMsgs.push(newMessage);
            msgMap.set(roomId, existingMsgs);
        }

        appendMessageToUI(msg) {
            const chatContainer = document.getElementById("messagesList");
            if (!chatContainer) return;
            
            const messageElement = this.createMessageElement(msg);
            chatContainer.appendChild(messageElement);

            // Scroll to bottom
            this.scrollToBottom();
        }

        // Manual Sync
        triggerManualSync() {
            if (this.currentUser) {
                this.socket.emit('trigger_sync', { email: this.currentUser.email });
                this.showToast('Manual sync triggered', 'info');
            }
        }

        // Helper Methods
        showScreen(screenName) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenName).classList.add('active');
        }

        showLoading(show = true) {
            const spinner = document.getElementById('loadingSpinner');
            if (spinner) {
                spinner.classList.toggle('hidden', !show);
            }
        }

        showToast(message, type = 'info') {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toastContainer';
                toastContainer.className = 'toast-container';
                document.body.appendChild(toastContainer);
            }
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            toastContainer.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 5000);
        }

        checkExistingSession() {
            const token = localStorage.getItem('matrix_access_token');
            const email = localStorage.getItem('user_email');
            
            if (token && email) {
                this.currentUser = { email, matrix_access_token: token };
                this.showScreen('appScreen');
                document.getElementById('userEmail').textContent = email;
                this.fetchedJoinedRooms();
                this.socket.emit('join_user', email);
                // Request initial sync via WebSocket
                this.socket.emit('request_sync', {
                    email: email,
                    since: localStorage.getItem('last_sync_token')
                });
            }
        }

        // Enhanced scrolling functionality
        initializeScrolling() {
            this.messagesContainer = document.getElementById('messagesContainer');
            this.autoScrollIndicator = document.getElementById('autoScrollIndicator');
            this.isAutoScrolling = true;
            
            if (this.messagesContainer && this.autoScrollIndicator) {
                // Listen for scroll events
                this.messagesContainer.addEventListener('scroll', () => {
                    this.handleScroll();
                });
                
                // Auto-scroll indicator click
                this.autoScrollIndicator.addEventListener('click', () => {
                    this.scrollToBottom();
                });
            }
        }

        handleScroll() {
            if (!this.messagesContainer) return;
            
            const container = this.messagesContainer;
            const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 50;
            
            if (isAtBottom) {
                this.isAutoScrolling = true;
                if (this.autoScrollIndicator) {
                    this.autoScrollIndicator.classList.add('hidden');
                }
            } else {
                this.isAutoScrolling = false;
                if (this.autoScrollIndicator) {
                    this.autoScrollIndicator.classList.remove('hidden');
                }
            }
        }

        // Enhanced message input functionality
        initializeMessageInput() {
            this.messageInput = document.getElementById('messageInput');
            this.sendBtn = document.getElementById('sendMessageBtn');
            this.charCounter = document.getElementById('charCounter');
            this.fileInput = document.getElementById('fileInput');
            this.aiRephraseBtn = document.getElementById('aiRephraseBtn');
            this.mediaPreview = document.getElementById('mediaPreview');
    
            if (!this.messageInput || !this.sendBtn) {
                console.error('Message input elements not found');
                return;
            }
            
            // Event listeners
            this.messageInput.addEventListener('input', (e) => {
                this.adjustTextareaHeight(e.target);
                this.toggleSendButton();
                this.updateCharCounter();
                this.toggleAIButton();
            });
            
            // AI Rephrase button event listener - UPDATED
if (this.aiRephraseBtn) {
    this.aiRephraseBtn.addEventListener('click', () => {
        this.handleAIRephrase();
    });
}
            
            this.messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
            
            this.messageInput.addEventListener('focus', () => {
                setTimeout(() => this.scrollToBottom(), 100);
            });
            
            // File input for multiple files - FIXED: accept all file types
            if (this.fileInput) {
                this.fileInput.multiple = true;
                this.fileInput.accept = '*/*'; // Accept all file types
                this.fileInput.addEventListener('change', (e) => {
                    this.handleFileSelection(e);
                });
            }

            // Emoji button
            const emojiBtn = document.getElementById('emojiBtn');
            if (emojiBtn) {
                emojiBtn.addEventListener('click', () => {
                    this.toggleEmojiPicker();
                });
            }

            // File attachment button
            const attachBtn = document.querySelector('.file-input-label');
            if (attachBtn) {
                attachBtn.addEventListener('click', () => {
                    if (this.fileInput) {
                        this.fileInput.click();
                    }
                });
            }
        }

       handleFileSelection(event) {
  const files = Array.from(event.target.files);
  if (files.length > 0) {
    // Validate file sizes
    const validFiles = files.filter(file => {
      if (file.size > 50 * 1024 * 1024) { // 50MB limit
        this.showToast(`File ${file.name} is too large (max 50MB)`, 'error');
        return false;
      }
      return true;
    });
    
    this.selectedFiles = [...this.selectedFiles, ...validFiles];
    this.renderMediaPreview();
    this.toggleSendButton();
    
    if (validFiles.length > 0) {
      if (validFiles.length === 1) {
        this.showToast(`1 file selected: ${validFiles[0].name}`, 'info');
      } else {
        this.showToast(`${validFiles.length} files selected`, 'info');
      }
    }
  }
}


        // NEW: Render media preview - FIXED
        renderMediaPreview() {
            if (!this.mediaPreview) return;
            
            this.mediaPreview.innerHTML = '';
            
            if (this.selectedFiles.length === 0) {
                this.mediaPreview.classList.add('hidden');
                return;
            }
            
            this.mediaPreview.classList.remove('hidden');
            
            this.selectedFiles.forEach((file, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'media-preview-item';
                
                if (file.type.startsWith('image/')) {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.alt = file.name;
                    previewItem.appendChild(img);
                } else if (file.type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(file);
                    video.controls = true;
                    previewItem.appendChild(video);
                } else if (file.type.startsWith('audio/')) {
                    const audio = document.createElement('audio');
                    audio.src = URL.createObjectURL(file);
                    audio.controls = true;
                    previewItem.appendChild(audio);
                } else {
                    const filePreview = document.createElement('div');
                    filePreview.className = 'file-preview';
                    const fileExtension = this.getFileExtension(file.name);
                    const fileIcon = this.getFileIcon(file.type, fileExtension);
                    
                    filePreview.innerHTML = `
                        <i class="${fileIcon}" style="font-size: 24px; margin-bottom: 5px;"></i>
                        <span style="font-size: 10px; word-break: break-all;">${file.name}</span>
                    `;
                    previewItem.appendChild(filePreview);
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-media';
                removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeFile(index);
                });
                
                previewItem.appendChild(removeBtn);
                this.mediaPreview.appendChild(previewItem);
            });
        }

        // NEW: Get file icon based on type
        getFileIcon(mimeType, extension) {
            if (mimeType.startsWith('image/')) return 'fas fa-file-image';
            if (mimeType.startsWith('video/')) return 'fas fa-file-video';
            if (mimeType.startsWith('audio/')) return 'fas fa-file-audio';
            if (mimeType.includes('pdf')) return 'fas fa-file-pdf';
            if (mimeType.includes('word') || extension === 'doc' || extension === 'docx') return 'fas fa-file-word';
            if (mimeType.includes('excel') || extension === 'xls' || extension === 'xlsx') return 'fas fa-file-excel';
            if (mimeType.includes('powerpoint') || extension === 'ppt' || extension === 'pptx') return 'fas fa-file-powerpoint';
            if (mimeType.includes('zip') || extension === 'zip' || extension === 'rar') return 'fas fa-file-archive';
            if (mimeType.includes('text') || extension === 'txt') return 'fas fa-file-alt';
            return 'fas fa-file';
        }

        // NEW: Remove file from selection
        removeFile(index) {
            this.selectedFiles.splice(index, 1);
            this.renderMediaPreview();
            this.toggleSendButton();
        }

        // NEW: Get file extension
        getFileExtension(filename) {
            return filename.split('.').pop().toLowerCase();
        }

        // COMPLETE REACTION SYSTEM
        initializeReactionSystem() {
            this.recentEmojis = JSON.parse(localStorage.getItem('recentEmojis') || '[]');
            this.currentReactionMessage = null;
            this.setupEmojiPicker();
        }

        setupEmojiPicker() {
            // Close emoji picker when clicking outside
            document.addEventListener('click', (e) => {
                const emojiPicker = document.getElementById('emojiPicker');
                if (emojiPicker && !emojiPicker.contains(e.target) && 
                    !e.target.closest('#emojiBtn') &&
                    !e.target.closest('.message-reaction-trigger')) {
                    this.hideEmojiPicker();
                }
            });

            // Close button
            document.querySelector('.close-emoji-picker').addEventListener('click', () => {
                this.hideEmojiPicker();
            });

            // Category switching
            document.querySelectorAll('.emoji-category').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const category = e.currentTarget.dataset.category;
                    this.switchEmojiCategory(category);
                });
            });

            // Quick reactions
            document.querySelectorAll('.quick-reaction').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const emoji = e.currentTarget.dataset.emoji;
                    this.addReactionToCurrentMessage(emoji);
                });
            });

            // Search functionality
            const searchInput = document.querySelector('.emoji-picker-search');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    this.filterEmojis(e.target.value);
                });
            }

            // Populate emojis
            this.populateEmojis();
        }

        populateEmojis() {
            const emojiCategories = {
                smileys: ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ˜‚', 'ðŸ¤£', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Œ', 'ðŸ˜', 'ðŸ¥°', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜™', 'ðŸ˜š', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ¤¨', 'ðŸ§', 'ðŸ¤“', 'ðŸ˜Ž', 'ðŸ¤©', 'ðŸ¥³', 'ðŸ˜', 'ðŸ˜’', 'ðŸ˜ž', 'ðŸ˜”', 'ðŸ˜Ÿ', 'ðŸ˜•', 'ðŸ™', 'â˜¹ï¸', 'ðŸ˜£', 'ðŸ˜–', 'ðŸ˜«', 'ðŸ˜©', 'ðŸ¥º', 'ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜¤', 'ðŸ˜ ', 'ðŸ˜¡', 'ðŸ¤¬', 'ðŸ¤¯', 'ðŸ˜³', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ˜±', 'ðŸ˜¨', 'ðŸ˜°', 'ðŸ˜¥', 'ðŸ˜“', 'ðŸ¤—', 'ðŸ¤”', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤¥', 'ðŸ˜¶', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¬', 'ðŸ™„', 'ðŸ˜¯', 'ðŸ˜¦', 'ðŸ˜§', 'ðŸ˜®', 'ðŸ˜²', 'ðŸ¥±', 'ðŸ˜´', 'ðŸ¤¤', 'ðŸ˜ª', 'ðŸ˜µ', 'ðŸ¤', 'ðŸ¥´', 'ðŸ¤¢', 'ðŸ¤®', 'ðŸ¤§', 'ðŸ˜·', 'ðŸ¤’', 'ðŸ¤•'],
                hearts: ['â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸ’”', 'â£ï¸', 'ðŸ’•', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’—', 'ðŸ’–', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'â™¥ï¸', 'â™¦ï¸', 'â™£ï¸', 'â™ ï¸'],
                thumbs: ['ðŸ‘', 'ðŸ‘Ž', 'ðŸ‘Œ', 'ðŸ¤', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™', 'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ‘‡', 'â˜ï¸', 'âœ‹', 'ðŸ¤š', 'ðŸ–ï¸', 'ðŸ––', 'ðŸ‘‹', 'ðŸ¤™', 'ðŸ’ª', 'ðŸ¦¾', 'ðŸ¦¿', 'ðŸ¦µ', 'ðŸ¦¶', 'ðŸ‘‚', 'ðŸ¦»', 'ðŸ‘ƒ', 'ðŸ§ ', 'ðŸ¦·', 'ðŸ¦´', 'ðŸ‘€', 'ðŸ‘ï¸', 'ðŸ‘…', 'ðŸ‘„']
            };

            // Populate each category
            Object.keys(emojiCategories).forEach(category => {
                const container = document.getElementById(`${category}Emojis`);
                if (container) {
                    container.innerHTML = emojiCategories[category].map(emoji => `
                        <button class="emoji-item" data-emoji="${emoji}">${emoji}</button>
                    `).join('');

                    // Add click listeners
                    container.querySelectorAll('.emoji-item').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const emoji = e.currentTarget.dataset.emoji;
                            console.log('ðŸŽ¯ Emoji selected from picker:', emoji);
                            console.log('ðŸ“ Current reaction message:', this.currentReactionMessage);
                            this.addReactionToCurrentMessage(emoji);
                        });
                    });
                }
            });

            // Populate recent emojis
            this.updateRecentEmojis();
        }

        updateRecentEmojis() {
            const container = document.getElementById('recentEmojis');
            if (container) {
                if (this.recentEmojis.length > 0) {
                    container.innerHTML = this.recentEmojis.map(emoji => `
                        <button class="emoji-item" data-emoji="${emoji}">${emoji}</button>
                    `).join('');

                    // Add click listeners
                    container.querySelectorAll('.emoji-item').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const emoji = e.currentTarget.dataset.emoji;
                            this.addReactionToCurrentMessage(emoji);
                        });
                    });
                } else {
                    container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #666; padding: 10px;">No recent emojis</div>';
                }
            }
        }

        addToRecentEmojis(emoji) {
            // Remove if already exists
            this.recentEmojis = this.recentEmojis.filter(e => e !== emoji);
            // Add to beginning
            this.recentEmojis.unshift(emoji);
            // Keep only last 12
            this.recentEmojis = this.recentEmojis.slice(0, 12);
            // Save to localStorage
            localStorage.setItem('recentEmojis', JSON.stringify(this.recentEmojis));
            // Update UI
            this.updateRecentEmojis();
        }

        switchEmojiCategory(category) {
            // Update active category
            document.querySelectorAll('.emoji-category').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.category === category);
            });

            // Show/hide sections
            document.querySelectorAll('.emoji-section').forEach(section => {
                section.style.display = 'none';
            });

            const targetSection = document.querySelector(`.${category}-section`);
            if (targetSection) {
                targetSection.style.display = 'block';
            }
        }

        filterEmojis(searchTerm) {
            const allEmojiItems = document.querySelectorAll('.emoji-item');
            allEmojiItems.forEach(item => {
                const emoji = item.dataset.emoji;
                const matches = emoji.includes(searchTerm) || this.getEmojiName(emoji).toLowerCase().includes(searchTerm.toLowerCase());
                item.style.display = matches ? 'flex' : 'none';
            });
        }

        getEmojiName(emoji) {
            const emojiNames = {
                'ðŸ‘': 'thumbs up', 'â¤ï¸': 'red heart', 'ðŸ˜„': 'smiling face', 'ðŸ˜®': 'surprised face',
                'ðŸ˜¢': 'crying face', 'ðŸ‘': 'clapping hands', 'ðŸ˜‚': 'laughing face', 'ðŸ”¥': 'fire',
                'â­': 'star', 'ðŸŽ‰': 'party popper', 'ðŸ™': 'folded hands', 'ðŸ˜': 'heart eyes'
            };
            return emojiNames[emoji] || emoji;
        }

        toggleEmojiPicker() {
            const emojiPicker = document.getElementById('emojiPicker');
            if (emojiPicker.classList.contains('show')) {
                this.hideEmojiPicker();
            } else {
                // Show for message input by default
                this.showEmojiPickerForInput();
            }
        }

        showEmojiPickerForMessage(messageElement, messageId) {
            console.log('ðŸŽ¯ Showing emoji picker for message:', messageId);
            
            if (!this.currentRoom || !this.currentUser) {
                console.error('âŒ Cannot show emoji picker: No room or user selected');
                this.showToast('Please select a conversation first', 'warning');
                return;
            }

            this.currentReactionMessage = {
                element: messageElement,
                id: messageId,
                roomId: this.currentRoom.roomId,
                platform: this.currentPlatform
            };

            const emojiPicker = document.getElementById('emojiPicker');
            if (!emojiPicker) {
                console.error('âŒ Emoji picker element not found');
                return;
            }

            // Better positioning logic
            const messageRect = messageElement.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const pickerWidth = 300;
            const pickerHeight = 400;

            // Calculate position - try to keep it visible
            let left = messageRect.right - pickerWidth;
            let top = messageRect.top - pickerHeight - 10;

            // Ensure it stays within viewport
            if (left < 10) left = 10;
            if (top < 10) top = 10;
            if (left + pickerWidth > viewportWidth - 10) {
                left = viewportWidth - pickerWidth - 10;
            }
            if (top + pickerHeight > viewportHeight - 10) {
                top = messageRect.bottom + 10; // Show below if no space above
            }

            // Apply positioning
            emojiPicker.style.position = 'fixed';
            emojiPicker.style.left = `${left}px`;
            emojiPicker.style.top = `${top}px`;
            emojiPicker.style.zIndex = '10000';
            emojiPicker.classList.add('show');

            // Reset and show recent emojis
            document.querySelector('.emoji-picker-search').value = '';
            this.switchEmojiCategory('recent');
            this.filterEmojis('');
            
            console.log('âœ… Emoji picker positioned for message reaction');
        }

        async addReactionToCurrentMessage(emoji) {
            // If no specific message is selected, add to text input
            if (!this.currentReactionMessage) {
                if (this.messageInput) {
                    this.messageInput.value += emoji;
                    this.adjustTextareaHeight(this.messageInput);
                    this.toggleSendButton();
                    this.updateCharCounter();
                }
                this.hideEmojiPicker();
                return;
            }

            const { id: messageId, roomId, platform } = this.currentReactionMessage;
            
            console.log('ðŸŽ¯ Adding reaction via emoji picker:', {
                messageId,
                roomId, 
                platform,
                emoji,
                currentUser: this.currentUser?.email
            });
            
            // Validate emoji
            if (!emoji || emoji === 'undefined') {
                console.error('âŒ Invalid emoji from picker:', emoji);
                this.showToast('Invalid emoji selected', 'error');
                this.hideEmojiPicker();
                return;
            }
            
            try {
                const response = await fetch('/send-reaction', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_email: this.currentUser.email,
                        room_id: roomId,
                        event_id: messageId,
                        emoji: emoji
                    })
                });

                console.log('ðŸ“¤ Reaction API Response status:', response.status);
                
                const data = await response.json();
                console.log('ðŸ“¥ Reaction API Response data:', data);

                if (data.success) {
                    this.addToRecentEmojis(emoji);
                    this.hideEmojiPicker();
                    this.showToast('Reaction added!', 'success');
                    
                    console.log('âœ… Reaction sent successfully, waiting for WebSocket update...');
                    
                    // Force reload messages to show updated reactions
                    setTimeout(() => {
                        if (this.currentRoom && this.currentRoom.roomId === roomId) {
                            this.openMsgRoom(this.currentPlatform, this.currentRoom.roomId);
                        }
                    }, 1000);
                } else {
                    this.showToast(data.error || 'Failed to add reaction', 'error');
                }
            } catch (err) {
                console.error('âŒ Reaction failed:', err);
                this.showToast('Failed to add reaction: ' + err.message, 'error');
            }
        }

        // Handle reaction updates from WebSocket
        handleReactionUpdate(data) {
            console.log('ðŸ”„ Reaction update received:', data);
            
            const reactionEvent = data;
            const messageId = reactionEvent.related_event_id;
            const roomId = reactionEvent.room_id;
            const emoji = reactionEvent.reaction_key;
            const sender = reactionEvent.sender;
            
            if (!messageId || !roomId || !emoji) {
                console.error('âŒ Invalid reaction data:', reactionEvent);
                return;
            }
            
            console.log('ðŸŽ¯ Processing reaction update:', { messageId, roomId, emoji, sender });
            
            // Update the message in the current view if we're in the right room
            if (this.currentRoom && roomId === this.currentRoom.roomId) {
                this.updateMessageReactionUI(messageId, emoji, sender);
            }
        }

        // Update message reactions in UI
        updateMessageReactionUI(messageId, emoji, sender) {
            console.log('ðŸ”„ Updating message reaction in UI:', { messageId, emoji, sender });
            
            const messageElement = document.querySelector(`[data-msg-id="${messageId}"]`);
            if (!messageElement) {
                console.log('âŒ Message element not found for ID:', messageId);
                return;
            }

            // Find or create reactions container
            let reactionsContainer = messageElement.querySelector('.message-reactions');
            if (!reactionsContainer) {
                reactionsContainer = document.createElement('div');
                reactionsContainer.className = 'message-reactions';
                const messageBubble = messageElement.querySelector('.message-bubble');
                if (messageBubble) {
                    messageBubble.appendChild(reactionsContainer);
                }
            }

            // Find existing reaction for this emoji
            const existingReaction = reactionsContainer.querySelector(`[data-emoji="${emoji}"]`);
            const isOwnReaction = sender === this.currentUser.email;

            if (existingReaction) {
                // Update existing reaction
                const countElement = existingReaction.querySelector('.reaction-count');
                if (countElement) {
                    const currentCount = parseInt(countElement.textContent) || 1;
                    countElement.textContent = currentCount + 1;
                } else {
                    const countSpan = document.createElement('span');
                    countSpan.className = 'reaction-count';
                    countSpan.textContent = '2';
                    existingReaction.appendChild(countSpan);
                }

                // Update own reaction status
                if (isOwnReaction) {
                    existingReaction.classList.add('own-reaction');
                }
            } else {
                // Create new reaction
                const reactionElement = document.createElement('div');
                reactionElement.className = `reaction ${isOwnReaction ? 'own-reaction' : ''}`;
                reactionElement.dataset.emoji = emoji;
                reactionElement.innerHTML = `
                    <span class="reaction-emoji">${emoji}</span>
                `;

                reactionElement.addEventListener('click', () => {
                    this.addReactionToMessage(messageId, emoji);
                });

                reactionsContainer.appendChild(reactionElement);
            }

            console.log('âœ… Reaction UI updated successfully');
        }

        // Add reaction to message (direct click on reaction)
        async addReactionToMessage(messageId, emoji) {
            console.log('ðŸŽ¯ Adding reaction to message:', messageId, emoji);
            
            if (!this.currentRoom || !this.currentUser) {
                console.error('âŒ Cannot add reaction: No room or user selected');
                this.showToast('Please select a conversation first', 'warning');
                return;
            }

            try {
                const response = await fetch('/send-reaction', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_email: this.currentUser.email,
                        room_id: this.currentRoom.roomId,
                        event_id: messageId,
                        emoji: emoji
                    })
                });

                const data = await response.json();

                if (data.success) {
                    this.addToRecentEmojis(emoji);
                    this.showToast('Reaction added!', 'success');
                    
                    // Force reload messages to show updated reactions
                    setTimeout(() => {
                        this.openMsgRoom(this.currentPlatform, this.currentRoom.roomId);
                    }, 500);
                } else {
                    this.showToast(data.error || 'Failed to add reaction', 'error');
                }
            } catch (err) {
                console.error('âŒ Reaction failed:', err);
                this.showToast('Failed to add reaction: ' + err.message, 'error');
            }
        }

        updateCharCounter() {
            if (!this.charCounter || !this.messageInput) return;
            
            const length = this.messageInput.value.length;
            const maxLength = 5000;
            this.charCounter.textContent = `${length}/${maxLength}`;
            
            if (length > maxLength * 0.9) {
                this.charCounter.style.color = '#dc3545';
            } else if (length > maxLength * 0.7) {
                this.charCounter.style.color = '#ffc107';
            } else {
                this.charCounter.style.color = '#666';
            }
        }

        // Toggle AI button based on text input
        toggleAIButton() {
            if (!this.aiRephraseBtn || !this.messageInput) return;
            
            const hasText = this.messageInput.value.trim().length > 0;
            this.aiRephraseBtn.disabled = !hasText;
        }

        // AI Rephrase functionality
        async handleAIRephrase() {
            const input = this.messageInput;
            const originalText = input.value.trim();

            if (!originalText) {
                this.showToast('Please enter some text to rephrase', 'warning');
                return;
            }

            if (!this.aiRephraseBtn) return;

            // Show loading state
            this.aiRephraseBtn.classList.add('loading');
            this.aiRephraseBtn.disabled = true;
            this.showLoading(true);

            try {
                const response = await fetch('/ai_rephrase', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        },
                    body: JSON.stringify({
                        text: originalText,
                        user_email: this.currentUser?.email,
                        room_id: this.currentRoom?.roomId,
                        platform: this.currentPlatform
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Show the AI rephrased text in the input area
                    const rephrasedText = data.rephrased_text || data.suggestion;
                    
                    // Replace the text in the input with the AI rephrased version
                    input.value = rephrasedText;
                    this.adjustTextareaHeight(input);
                    this.toggleSendButton();
                    this.updateCharCounter();
                    
                    this.showToast('Text rephrased with AI! Review and click send.', 'success');
                    
                    // Focus on the input so user can edit or send immediately
                    input.focus();
                    
                } else {
                    this.showToast(data.error || 'Failed to rephrase text', 'error');
                }
            } catch (error) {
                console.error('AI rephrase error:', error);
                this.showToast('Failed to connect to AI service', 'error');
            } finally {
                // Remove loading state
                this.aiRephraseBtn.classList.remove('loading');
                this.toggleAIButton();
                this.showLoading(false);
            }
        }

        adjustTextareaHeight(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        }

        toggleSendButton() {
            if (!this.messageInput || !this.sendBtn) return;
            
            const hasText = this.messageInput.value.trim().length > 0;
            const hasFiles = this.selectedFiles.length > 0;
            this.sendBtn.disabled = !(hasText || hasFiles);
        }

        // FIXED: Enhanced sendMessage function
        async sendMessage() {
  if (!this.messageInput) return;
  
  const input = this.messageInput;
  const text = input.value.trim();
  const files = this.selectedFiles;

  console.log('ðŸ” Sending message - Text:', text, 'Files:', files.map(f => f.name));

  if (!text && files.length === 0) {
    this.showToast('Please enter a message or select a file', 'warning');
    return;
  }
  
  if (!this.currentRoom || !this.currentUser || !this.currentPlatform) {
    this.showToast('Please select a conversation first', 'warning');
    return;
  }

  this.showLoading(true);

  try {
    let response;
    
    const messageData = {
      email: this.currentUser.email,
      roomId: this.currentRoom.roomId
    };
    
    let replyData = null;
    if (this.currentReplyMessage) {
      replyData = {
        id: this.currentReplyMessage.id || this.currentReplyMessage.event_id,
        sender: this.currentReplyMessage.sender || this.currentReplyMessage.sender_id,
        content: this.currentReplyMessage.content?.text || this.currentReplyMessage.body || 'Original message'
      };
    }
    
    if (files.length > 0) {
      const formData = new FormData();
      formData.append('email', this.currentUser.email);
      formData.append('roomId', this.currentRoom.roomId);
      
      files.forEach((file) => {
        formData.append('files', file);
      });
      
      if (text) {
        formData.append('text', text);
      }
      
      if (replyData) {
        formData.append('reply_to', JSON.stringify(replyData));
      }

      console.log('ðŸ“¤ Sending FormData with files');
      
      response = await fetch('/api/sendMessage', {
        method: 'POST',
        body: formData
      });
    } else {
      if (text) {
        messageData.text = text;
      }
      
      if (replyData) {
        messageData.reply_to = JSON.stringify(replyData);
      }
      
      console.log('ðŸ“¤ Sending JSON data');
      
      response = await fetch('/api/sendMessage', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(messageData)
      });
    }

    console.log('ðŸ“¥ Response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('âŒ Server error response:', errorText);
      throw new Error(`Server responded with ${response.status}: ${errorText}`);
    }

    const data = await response.json();
    console.log('ðŸ“¥ Send message response:', data);

    if (data.success) {
      input.value = '';
      this.selectedFiles = [];
      this.renderMediaPreview();
      this.adjustTextareaHeight(input);
      this.toggleSendButton();
      this.updateCharCounter();
      
      this.cancelReply();
      
      this.showToast('Message sent successfully!', 'success');
      
      this.updateRoomLastMessage(this.currentRoom.roomId, text, Date.now());
      
      setTimeout(() => {
        this.openMsgRoom(this.currentPlatform, this.currentRoom.roomId);
      }, 1000);
      
    } else {
      this.showToast(data.error || 'Failed to send message', 'error');
      if (data.details) {
        console.error('Error details:', data.details);
      }
    }
  } catch (error) {
    console.error('âŒ Error sending message:', error);
    this.showToast('Failed to send message: ' + error.message, 'error');
  } finally {
    this.showLoading(false);
  }
}

        // NEW: Emoji picker for input
        showEmojiPickerForInput() {
            const emojiPicker = document.getElementById('emojiPicker');
            if (!emojiPicker) return;
            
            // Position near the emoji button
            const emojiBtn = document.getElementById('emojiBtn');
            if (emojiBtn) {
                const rect = emojiBtn.getBoundingClientRect();
                emojiPicker.style.position = 'fixed';
                emojiPicker.style.bottom = '80px';
                emojiPicker.style.right = '20px';
                emojiPicker.style.zIndex = '10000';
            }
            
            emojiPicker.classList.add('show');
            
            // Reset and show recent emojis
            document.querySelector('.emoji-picker-search').value = '';
            this.switchEmojiCategory('recent');
            this.filterEmojis('');
            
            // Set current reaction message to null for input
            this.currentReactionMessage = null;
        }

        // NEW: Hide emoji picker
        hideEmojiPicker() {
            const emojiPicker = document.getElementById('emojiPicker');
            if (emojiPicker) {
                emojiPicker.classList.remove('show');
            }
        }

        // NEW: Initialize reply system
        initializeReplySystem() {
            this.currentReplyMessage = null;
            this.contextMenuMessage = null;
        }

        // NEW: Handle reply from context menu
        handleReplyFromContextMenu() {
            if (!this.contextMenuMessage) return;
            
            this.setReplyMessage(this.contextMenuMessage);
            document.getElementById('messageContextMenu').classList.remove('show');
        }

        // NEW: Handle copy from context menu
        handleCopyFromContextMenu() {
            if (!this.contextMenuMessage) return;
            
            const textToCopy = this.contextMenuMessage.content?.text || this.contextMenuMessage.body;
            if (textToCopy) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    this.showToast('Message copied to clipboard', 'success');
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    this.showToast('Failed to copy message', 'error');
                });
            }
            
            document.getElementById('messageContextMenu').classList.remove('show');
        }

        // NEW: Handle delete from context menu
        handleDeleteFromContextMenu() {
            if (!this.contextMenuMessage) return;
            
            // In a real app, you would send a delete request to the server
            this.showToast('Delete functionality would be implemented with backend support', 'info');
            document.getElementById('messageContextMenu').classList.remove('show');
        }

        // NEW: Set reply message and show preview
        setReplyMessage(message) {
            this.currentReplyMessage = message;
            
            // Show reply preview
            const replyPreview = document.getElementById('replyPreview');
            const replyPreviewSender = document.getElementById('replyPreviewSender');
            const replyPreviewText = document.getElementById('replyPreviewText');
            
            if (replyPreview && replyPreviewSender && replyPreviewText) {
                const senderName = message.sender === this.currentUser.email ? 'You' : 
                    (message.senderName || message.sender.split(':')[0].replace('@', ''));
                
                const previewText = message.content?.text || message.body || 'Original message';
                
                replyPreviewSender.textContent = senderName;
                replyPreviewText.textContent = previewText.length > 50 ? 
                    previewText.substring(0, 50) + '...' : previewText;
                
                replyPreview.classList.remove('hidden');
            }
            
            // Focus on message input
            if (this.messageInput) {
                this.messageInput.focus();
            }
            
            this.showToast('Replying to message', 'info');
        }

        // NEW: Cancel reply
        cancelReply() {
            this.currentReplyMessage = null;
            document.getElementById('replyPreview').classList.add('hidden');
        }

        // NEW: Scroll to specific message
        scrollToMessage(messageId) {
            const messageElement = document.querySelector(`[data-msg-id="${messageId}"]`);
            if (messageElement) {
                messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Add highlight effect
                messageElement.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
                messageElement.style.transition = 'background-color 0.5s ease';
                
                setTimeout(() => {
                    messageElement.style.backgroundColor = '';
                }, 2000);
            }
        }

        // Utility Methods
        formatTime(timestamp) {
            if (!timestamp) return '';
            
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'now';
            if (diffMins < 60) return `${diffMins}m`;
            if (diffHours < 24) return `${diffHours}h`;
            if (diffDays < 7) return `${diffDays}d`;
            
            return date.toLocaleDateString();
        }

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            if (!container) return;
            
            container.scrollTop = container.scrollHeight;
            this.isAutoScrolling = true;
            if (this.autoScrollIndicator) {
                this.autoScrollIndicator.classList.add('hidden');
            }
        }

        openMedia(url) {
            window.open(url, '_blank');
        }

        debugReactionFlow(platform, roomId, messageId, emoji) {
            console.log('ðŸ” Reaction Debug:', {
                platform,
                roomId,
                messageId,
                emoji,
                currentUser: this.currentUser?.email,
                currentRoom: this.currentRoom?.roomId,
                currentPlatform: this.currentPlatform
            });
        }

        maintainMsgCache(msgMap, limit) {
            if (msgMap.size > limit) {
                const oldestRoomId = msgMap.keys().next().value;
                msgMap.delete(oldestRoomId);
                console.log(`Cleared oldest room: ${oldestRoomId}`);
            }
        }

        renderRoomMessages(platform, roomId) {
            console.log(`Rendering messages for ${platform} room: ${roomId}`);
            
            const msgMap = this.getMsgMap(platform);
            const messages = msgMap.get(roomId) || [];
            const chatContainer = document.getElementById("messagesList");

            console.log(`Found ${messages.length} messages to render`);

            chatContainer.innerHTML = ""; 

            if (messages.length === 0) {
                chatContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-comments" style="font-size: 3rem; margin-bottom: 15px;"></i>
                        <p>No messages yet</p>
                        <small>Start a conversation by sending a message</small>
                    </div>
                `;
            } else {
                messages.forEach(msg => {
                    const messageElement = this.createMessageElement(msg);
                    chatContainer.appendChild(messageElement);
                });
            }

            // Scroll to bottom after a short delay to ensure rendering is complete
            setTimeout(() => {
                this.scrollToBottom();
            }, 100);
            
            console.log('Messages rendered successfully');
        }

        // Enhanced message element creation with reactions and replies
        createMessageElement(msg) {
            const messageDiv = document.createElement('div');
            
            // Safely determine if message is sent by current user
            const isSent = msg.sender === this.currentUser?.email || 
                       msg.sender_id === this.currentUser?.email ||
                       (msg.sender && msg.sender.includes(this.currentUser?.email.split('@')[0]));

            // Get sender name safely
            let senderDisplayName = 'Unknown';
            if (msg.sender_name) {
                senderDisplayName = msg.sender_name;
            } else if (msg.sender && typeof msg.sender === 'string') {
                // Extract username from atID like "@user:domain.com"
                const match = msg.sender.match(/@([^:]+):/);
                senderDisplayName = match ? match[1] : msg.sender;
            } else if (msg.sender_id && typeof msg.sender_id === 'string') {
                const match = msg.sender_id.match(/@([^:]+):/);
                senderDisplayName = match ? match[1] : msg.sender_id;
            }

            // Add reaction trigger button
            const reactionTrigger = document.createElement('button');
            reactionTrigger.className = 'message-reaction-trigger';
            reactionTrigger.innerHTML = '<i class="fas fa-smile"></i>';
            reactionTrigger.title = 'Add reaction';
            reactionTrigger.style.display = 'flex';

            // Add click event with better debugging
            reactionTrigger.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('ðŸŽ¯ Reaction trigger CLICKED for message:', msg.id);
                console.log('ðŸ“ Current room:', this.currentRoom);
                console.log('ðŸ‘¤ Current user:', this.currentUser?.email);
                
                if (!this.currentRoom || !this.currentUser) {
                    console.error('âŒ No room or user selected');
                    this.showToast('Please select a conversation first', 'warning');
                    return;
                }
                
                this.showEmojiPickerForMessage(messageDiv, msg.id);
            });

            let contentHtml = '';
            
            // Handle different message types
            switch(msg.type) {
                case "m.text":
                case "m.notice":
                    contentHtml = msg.content?.text || msg.body || "[No text content]";
                    break;
                case "m.image":
                    const imageUrl = msg.content?.fileUrl || msg.content?.url;
                    if (imageUrl) {
                        contentHtml = `
                            <img src="${imageUrl}" class="message-media" onclick="app.openMedia('${imageUrl}')">
                            <button class="download-btn" onclick="app.downloadMedia('${imageUrl}', '${msg.content?.fileName || 'image'}')">
                                <i class="fas fa-download"></i> Download
                            </button>
                        `;
                    } else {
                        contentHtml = `ðŸ“· [Image: ${msg.content?.fileName || msg.body || "Image"}]`;
                    }
                    break;
                case "m.video":
                    const videoUrl = msg.content?.fileUrl || msg.content?.url;
                    if (videoUrl) {
                        contentHtml = `
                            <video controls src="${videoUrl}" class="message-media"></video>
                            <button class="download-btn" onclick="app.downloadMedia('${videoUrl}', '${msg.content?.fileName || 'video'}')">
                                <i class="fas fa-download"></i> Download
                            </button>
                        `;
                    } else {
                        contentHtml = `ðŸŽ¥ [Video: ${msg.content?.fileName || msg.body || "Video"}]`;
                    }
                    break;
                case "m.file":
                    const fileUrl = msg.content?.fileUrl || msg.content?.url;
                    if (fileUrl) {
                        contentHtml = `
                            <div class="file-preview" style="padding: 10px; background: #f8f9fa; border-radius: 8px; margin-bottom: 8px;">
                                <i class="fas fa-file" style="font-size: 24px; margin-bottom: 5px;"></i>
                                <div style="font-size: 12px; color: #666;">${msg.content?.fileName || "Download File"}</div>
                            </div>
                            <button class="download-btn" onclick="app.downloadMedia('${fileUrl}', '${msg.content?.fileName || 'file'}')">
                                <i class="fas fa-download"></i> Download File
                            </button>
                        `;
                    } else {
                        contentHtml = `ðŸ“Ž [File: ${msg.content?.fileName || msg.body || "File"}]`;
                    }
                    break;
                case "m.audio":
                    const audioUrl = msg.content?.fileUrl || msg.content?.url;
                    if (audioUrl) {
                        contentHtml = `
                            <audio controls src="${audioUrl}" class="message-media"></audio>
                            <button class="download-btn" onclick="app.downloadMedia('${audioUrl}', '${msg.content?.fileName || 'audio'}')">
                                <i class="fas fa-download"></i> Download
                            </button>
                        `;
                    } else {
                        contentHtml = `ðŸŽµ [Audio: ${msg.content?.fileName || msg.body || "Audio"}]`;
                    }
                    break;
                case "m.reaction":
                    // This is a reaction message
                    if (msg.relatesTo && msg.reactionEmoji) {
                        contentHtml = `Reacted ${msg.reactionEmoji} to a message`;
                    } else {
                        contentHtml = `[Reaction]`;
                    }
                    break;
                case "system":
                    contentHtml = `<em>${msg.content?.text || msg.body || "System message"}</em>`;
                    break;
                default:
                    console.warn('Unknown message type:', msg.type, msg);
                    contentHtml = `[Unsupported message type: ${msg.type}]`;
            }

            // Add reactions if they exist
            let reactionsHtml = '';
            if (msg.reactions && msg.reactions.length > 0) {
                console.log(`ðŸŽ­ Rendering ${msg.reactions.length} reactions for message ${msg.id}:`, msg.reactions);
                
                reactionsHtml = `<div class="message-reactions">`;
                msg.reactions.forEach(reaction => {
                    // FIX: Check if reaction object has proper structure
                    const reactionEmoji = reaction.emoji || reaction.key;
                    const reactionCount = reaction.count || 1;
                    const isOwnReaction = reaction.senders && reaction.senders.includes(this.currentUser.email);
                    
                    console.log(`ðŸŽ¯ Rendering reaction: ${reactionEmoji} (count: ${reactionCount})`);
                    
                    if (reactionEmoji && reactionEmoji !== 'undefined') {
                        reactionsHtml += `
                            <div class="reaction ${isOwnReaction ? 'own-reaction' : ''}" 
                                 onclick="app.addReactionToMessage('${msg.id}', '${reactionEmoji}')"
                                 data-emoji="${reactionEmoji}">
                                <span class="reaction-emoji">${reactionEmoji}</span>
                                ${reactionCount > 1 ? `<span class="reaction-count">${reactionCount}</span>` : ''}
                            </div>
                        `;
                    } else {
                        console.warn('âš ï¸ Skipping invalid reaction:', reaction);
                    }
                });
                reactionsHtml += `</div>`;
            }

            // NEW: Add reply preview if message is a reply
            let replyHtml = '';
            if (msg.reply_to) {
                // Safely get reply sender name
                let replySenderName = 'Unknown';
                if (msg.reply_to.sender === this.currentUser?.email) {
                    replySenderName = 'You';
                } else if (msg.reply_to.senderName) {
                    replySenderName = msg.reply_to.senderName;
                } else if (msg.reply_to.sender && typeof msg.reply_to.sender === 'string') {
                    replySenderName = msg.reply_to.sender.split(':')[0].replace('@', '');
                }
                
                replyHtml = `
                    <div class="message-reply" onclick="app.scrollToMessage('${msg.reply_to.id}')">
                        <div class="message-reply-header">${this.escapeHtml(replySenderName)}</div>
                        <div class="message-reply-text">${this.escapeHtml(msg.reply_to.content || 'Original message')}</div>
                    </div>
                `;
            }

            // Format timestamp
            const timestamp = msg.timestamp || msg.origin_server_ts || Date.now();
            const timeString = this.formatTime(timestamp);

            messageDiv.innerHTML = `
                <div class="message-bubble">
                    ${!isSent ? `<div class="message-sender">${this.escapeHtml(senderDisplayName)}</div>` : ''}
                    ${replyHtml}
                    <div class="message-content">${contentHtml}</div>
                    ${reactionsHtml}
                    <div class="message-time">${timeString}</div>
                </div>
            `;

            // Add reaction trigger to the message
            const messageBubble = messageDiv.querySelector('.message-bubble');
            if (messageBubble) {
                messageBubble.style.position = 'relative';
                messageBubble.appendChild(reactionTrigger);
            }

            // NEW: Add context menu trigger
            messageDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                this.showMessageContextMenu(e, msg);
            });

            // NEW: Add long press for mobile
            let pressTimer;
            messageDiv.addEventListener('touchstart', (e) => {
                pressTimer = setTimeout(() => {
                    this.showMessageContextMenu(e, msg);
                }, 500);
            });

            messageDiv.addEventListener('touchend', () => {
                clearTimeout(pressTimer);
            });

            return messageDiv;
        }

        // NEW: Download media function
        downloadMedia(url, filename) {
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.target = '_blank';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // NEW: Show message context menu
        showMessageContextMenu(e, msg) {
            const contextMenu = document.getElementById('messageContextMenu');
            if (!contextMenu) return;
            
            this.contextMenuMessage = msg;
            
            // Position the context menu
            const x = e.clientX || e.touches[0].clientX;
            const y = e.clientY || e.touches[0].clientY;
            
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.classList.add('show');
        }

        getPlatformIcon(platform) {
            const platformNormalized = platform.charAt(0).toUpperCase() + platform.slice(1).toLowerCase();
            switch(platformNormalized) {
                case 'Whatsapp': return 'fab fa-whatsapp';
                case 'Telegram': return 'fab fa-telegram';
                case 'Instagram': return 'fab fa-instagram';
                case 'Twitter': return 'fab fa-twitter';
                case 'Email': return 'fas fa-envelope';
                default: return 'fas fa-comment';
            }
        }

        getPlatformColor(platform) {
            const platformNormalized = platform.charAt(0).toUpperCase() + platform.slice(1).toLowerCase();
            switch(platformNormalized) {
                case 'Whatsapp': return '#25D366';
                case 'Telegram': return '#0088cc';
                case 'Instagram': return '#E4405F';
                case 'Twitter': return '#1DA1F2';
                case 'Email': return '#6c757d';
                default: return '#6c757d';
            }
        }
    }

    // Initialize the app when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        window.app = new UnifiedMessagingApp();
    });
</script>
</body>
</html>